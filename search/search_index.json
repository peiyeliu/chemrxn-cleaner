{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"chemrxn-cleaner \u00b6 Helpers for parsing, cleaning, filtering, reporting, and exporting organic reaction datasets before ML or analytics workflows. Installation \u00b6 Requires Python 3.9+ with RDKit available in the environment (platform-specific wheels are not bundled). Install the package directly: pip install chemrxn-cleaner Quick start \u00b6 from chemrxn_cleaner import ( clean_and_canonicalize , clean_reactions_with_report , default_filters , export_reaction_records , load_reactions , ) raw = load_reactions ( \"data/sample.rsmi\" , fmt = \"uspto\" , keep_meta = True ) filters = default_filters () cleaned = clean_and_canonicalize ( raw , filters = filters ) cleaned_with_report , stats = clean_reactions_with_report ( raw , filters = filters ) print ( f \"Input: { stats . n_input } , output: { stats . n_output } , failed: { stats . n_failed_parse } \" ) export_reaction_records ( cleaned , \"cleaned.json\" , fmt = \"json\" ) Loading reaction data \u00b6 Use the format registry instead of hand-rolled parsers: from chemrxn_cleaner import load_reactions uspto_rxns = load_reactions ( \"data/uspto_sample.rsmi\" , fmt = \"uspto\" , keep_meta = True ) ord_rxns = load_reactions ( \"data/ord_dataset.pb.gz\" , fmt = \"ord\" , generate_if_missing = True , allow_incomplete = True , canonical = True , ) Register your own loader for custom formats: from chemrxn_cleaner import register_input_format from chemrxn_cleaner.types import ReactionRecord def load_my_format ( path : str ): rec = ReactionRecord ( reaction_smiles = \"A>B>C\" , source = \"myfmt\" ) return [ rec ] register_input_format ( \"myfmt\" , load_my_format ) rxns = load_reactions ( \"my_file.txt\" , fmt = \"myfmt\" ) Cleaning and reporting \u00b6 Filters are plain callables. Compose the built-ins or author your own: from chemrxn_cleaner import ( clean_and_canonicalize , clean_reactions_with_report , default_filters , max_smiles_length , ) filters = default_filters () + [ max_smiles_length ( 250 )] cleaned , stats = clean_reactions_with_report ( raw , filters = filters ) canonicalized = clean_and_canonicalize ( cleaned , filters = filters , isomeric = True ) print ( stats . per_filter [ \"max_smiles_length\" ] . failed ) Exports and ML utilities \u00b6 from chemrxn_cleaner import ( ForwardReactionDataset , export_reaction_records , records_to_dataframe , train_valid_test_split , ) df = records_to_dataframe ( cleaned ) export_reaction_records ( cleaned , \"cleaned.csv\" , fmt = \"csv\" ) train , valid , test = train_valid_test_split ( cleaned , seed = 123 ) dataset = ForwardReactionDataset ( train , use_agents = True ) The API reference page documents every helper in detail.","title":"Home"},{"location":"#chemrxn-cleaner","text":"Helpers for parsing, cleaning, filtering, reporting, and exporting organic reaction datasets before ML or analytics workflows.","title":"chemrxn-cleaner"},{"location":"#installation","text":"Requires Python 3.9+ with RDKit available in the environment (platform-specific wheels are not bundled). Install the package directly: pip install chemrxn-cleaner","title":"Installation"},{"location":"#quick-start","text":"from chemrxn_cleaner import ( clean_and_canonicalize , clean_reactions_with_report , default_filters , export_reaction_records , load_reactions , ) raw = load_reactions ( \"data/sample.rsmi\" , fmt = \"uspto\" , keep_meta = True ) filters = default_filters () cleaned = clean_and_canonicalize ( raw , filters = filters ) cleaned_with_report , stats = clean_reactions_with_report ( raw , filters = filters ) print ( f \"Input: { stats . n_input } , output: { stats . n_output } , failed: { stats . n_failed_parse } \" ) export_reaction_records ( cleaned , \"cleaned.json\" , fmt = \"json\" )","title":"Quick start"},{"location":"#loading-reaction-data","text":"Use the format registry instead of hand-rolled parsers: from chemrxn_cleaner import load_reactions uspto_rxns = load_reactions ( \"data/uspto_sample.rsmi\" , fmt = \"uspto\" , keep_meta = True ) ord_rxns = load_reactions ( \"data/ord_dataset.pb.gz\" , fmt = \"ord\" , generate_if_missing = True , allow_incomplete = True , canonical = True , ) Register your own loader for custom formats: from chemrxn_cleaner import register_input_format from chemrxn_cleaner.types import ReactionRecord def load_my_format ( path : str ): rec = ReactionRecord ( reaction_smiles = \"A>B>C\" , source = \"myfmt\" ) return [ rec ] register_input_format ( \"myfmt\" , load_my_format ) rxns = load_reactions ( \"my_file.txt\" , fmt = \"myfmt\" )","title":"Loading reaction data"},{"location":"#cleaning-and-reporting","text":"Filters are plain callables. Compose the built-ins or author your own: from chemrxn_cleaner import ( clean_and_canonicalize , clean_reactions_with_report , default_filters , max_smiles_length , ) filters = default_filters () + [ max_smiles_length ( 250 )] cleaned , stats = clean_reactions_with_report ( raw , filters = filters ) canonicalized = clean_and_canonicalize ( cleaned , filters = filters , isomeric = True ) print ( stats . per_filter [ \"max_smiles_length\" ] . failed )","title":"Cleaning and reporting"},{"location":"#exports-and-ml-utilities","text":"from chemrxn_cleaner import ( ForwardReactionDataset , export_reaction_records , records_to_dataframe , train_valid_test_split , ) df = records_to_dataframe ( cleaned ) export_reaction_records ( cleaned , \"cleaned.csv\" , fmt = \"csv\" ) train , valid , test = train_valid_test_split ( cleaned , seed = 123 ) dataset = ForwardReactionDataset ( train , use_agents = True ) The API reference page documents every helper in detail.","title":"Exports and ML utilities"},{"location":"api/","text":"API reference \u00b6 chemrxn_cleaner \u00b6 ElementFilterRule dataclass \u00b6 Allowed or forbidden element symbols by reaction role. Attributes: Name Type Description reactantElements List [ str ] Allowed/forbidden element symbols for reactants. reagentElements List [ str ] Allowed/forbidden element symbols for reagents. productElements List [ str ] Allowed/forbidden element symbols for products. Source code in chemrxn_cleaner/filters.py 13 14 15 16 17 18 19 20 21 22 23 24 25 @dataclass class ElementFilterRule : \"\"\"Allowed or forbidden element symbols by reaction role. Attributes: reactantElements: Allowed/forbidden element symbols for reactants. reagentElements: Allowed/forbidden element symbols for reagents. productElements: Allowed/forbidden element symbols for products. \"\"\" reactantElements : List [ str ] reagentElements : List [ str ] productElements : List [ str ] ForwardReactionDataset \u00b6 Bases: Dataset Minimal forward-prediction dataset built on top of ReactionRecord. Source code in chemrxn_cleaner/ml/dataset.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 class ForwardReactionDataset ( Dataset ): \"\"\"Minimal forward-prediction dataset built on top of ReactionRecord.\"\"\" def __init__ ( self , records : List [ ReactionRecord ], use_agents : bool = True , ): \"\"\"Initialize the dataset. Args: records: Reaction records providing inputs and targets. use_agents: When True, include reagents/agents on the input side. \"\"\" self . records = records self . use_agents = use_agents def __len__ ( self ) -> int : \"\"\"Return the number of reactions in the dataset.\"\"\" return len ( self . records ) def _make_input_smiles ( self , r : ReactionRecord ) -> str : \"\"\"Assemble the left-hand-side SMILES string for a record. Args: r: Reaction record providing input SMILES pieces. Returns: Dot-joined SMILES string for model input. \"\"\" # left side = reactants [+ (reagents/solvents/agents)] left_parts = list ( r . reactant_smiles ) if self . use_agents : left_parts += r . reagent_smiles return \".\" . join ( left_parts ) def __getitem__ ( self , idx : int ) -> Dict [ str , Any ]: \"\"\"Return model-ready input/target pair and metadata for an index. Args: idx: Integer index into the records list. Returns: Dictionary containing ``input_smiles``, ``target_smiles``, and metadata useful for downstream models. \"\"\" r = self . records [ idx ] x = self . _make_input_smiles ( r ) y = \".\" . join ( r . product_smiles ) return { \"input_smiles\" : x , \"target_smiles\" : y , \"reaction_id\" : r . reaction_id , \"meta\" : { \"temperature_c\" : r . temperature_c , \"time_hours\" : r . time_hours , \"solvents\" : r . solvents , \"catalysts\" : r . catalysts , \"bases\" : r . bases , \"additives\" : r . additives , \"source\" : r . source , }, } _make_input_smiles \u00b6 _make_input_smiles ( r ) Assemble the left-hand-side SMILES string for a record. Parameters: Name Type Description Default r ReactionRecord Reaction record providing input SMILES pieces. required Returns: Type Description str Dot-joined SMILES string for model input. Source code in chemrxn_cleaner/ml/dataset.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def _make_input_smiles ( self , r : ReactionRecord ) -> str : \"\"\"Assemble the left-hand-side SMILES string for a record. Args: r: Reaction record providing input SMILES pieces. Returns: Dot-joined SMILES string for model input. \"\"\" # left side = reactants [+ (reagents/solvents/agents)] left_parts = list ( r . reactant_smiles ) if self . use_agents : left_parts += r . reagent_smiles return \".\" . join ( left_parts ) CleaningStats dataclass \u00b6 Aggregate statistics for the overall cleaning process. Attributes: Name Type Description n_input int Total number of reactions processed. n_output int Total number of reactions kept after filtering. n_failed_parse int Number of reactions that failed SMILES parsing. per_filter Dict [ str , FilterStats ] Mapping of filter name to per-filter counters. Source code in chemrxn_cleaner/reporter.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 @dataclass class CleaningStats : \"\"\"Aggregate statistics for the overall cleaning process. Attributes: n_input: Total number of reactions processed. n_output: Total number of reactions kept after filtering. n_failed_parse: Number of reactions that failed SMILES parsing. per_filter: Mapping of filter name to per-filter counters. \"\"\" n_input : int = 0 n_output : int = 0 n_failed_parse : int = 0 per_filter : Dict [ str , FilterStats ] = field ( default_factory = dict ) def _merge_filter_stats ( self , source : Dict [ str , FilterStats ]) -> None : \"\"\"Accumulate filter-level counters from another mapping. Args: source: Mapping of filter names to stats to merge into this object. \"\"\" for name , fstats in source . items (): merged = self . per_filter . setdefault ( name , FilterStats ( name = name )) merged . applied += fstats . applied merged . passed += fstats . passed merged . failed += fstats . failed def __iadd__ ( self , other : \"CleaningStats\" ) -> \"CleaningStats\" : \"\"\"In-place addition of counters from another ``CleaningStats``. Args: other: Cleaning statistics to combine into this instance. Returns: This instance after accumulation. \"\"\" if not isinstance ( other , CleaningStats ): return NotImplemented self . n_input += other . n_input self . n_output += other . n_output self . n_failed_parse += other . n_failed_parse self . _merge_filter_stats ( other . per_filter ) return self def __add__ ( self , other : \"CleaningStats\" ) -> \"CleaningStats\" : \"\"\"Return a new ``CleaningStats`` combining two instances. Args: other: Cleaning statistics to add to this instance. Returns: A new ``CleaningStats`` containing summed counters. \"\"\" if not isinstance ( other , CleaningStats ): return NotImplemented combined = CleaningStats ( n_input = self . n_input , n_output = self . n_output , n_failed_parse = self . n_failed_parse , ) combined . _merge_filter_stats ( self . per_filter ) combined += other return combined @classmethod def combine ( cls , stats_list : Iterable [ \"CleaningStats\" ]) -> \"CleaningStats\" : \"\"\"Combine multiple ``CleaningStats`` objects (e.g., from parallel runs). Args: stats_list: Iterable of statistics objects to aggregate. Returns: Aggregate statistics across all provided objects. \"\"\" combined = cls () for stats in stats_list : combined += stats return combined def summary ( self , include_filters : bool = True ) -> str : \"\"\"Return a formatted string summarizing counters. Args: include_filters: Whether to include per-filter breakdowns. Returns: Multiline string representation of the aggregated counters. \"\"\" lines = [ f \"Input: { self . n_input } , output: { self . n_output } , \" f \"failed_parse: { self . n_failed_parse } \" ] if include_filters and self . per_filter : lines . append ( \"Per-filter:\" ) for name in sorted ( self . per_filter . keys ()): lines . append ( f \" { self . per_filter [ name ] } \" ) return \" \\n \" . join ( lines ) def __str__ ( self ) -> str : return self . summary () _merge_filter_stats \u00b6 _merge_filter_stats ( source ) Accumulate filter-level counters from another mapping. Parameters: Name Type Description Default source Dict [ str , FilterStats ] Mapping of filter names to stats to merge into this object. required Source code in chemrxn_cleaner/reporter.py 52 53 54 55 56 57 58 59 60 61 62 def _merge_filter_stats ( self , source : Dict [ str , FilterStats ]) -> None : \"\"\"Accumulate filter-level counters from another mapping. Args: source: Mapping of filter names to stats to merge into this object. \"\"\" for name , fstats in source . items (): merged = self . per_filter . setdefault ( name , FilterStats ( name = name )) merged . applied += fstats . applied merged . passed += fstats . passed merged . failed += fstats . failed combine classmethod \u00b6 combine ( stats_list ) Combine multiple CleaningStats objects (e.g., from parallel runs). Parameters: Name Type Description Default stats_list Iterable ['CleaningStats'] Iterable of statistics objects to aggregate. required Returns: Type Description 'CleaningStats' Aggregate statistics across all provided objects. Source code in chemrxn_cleaner/reporter.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 @classmethod def combine ( cls , stats_list : Iterable [ \"CleaningStats\" ]) -> \"CleaningStats\" : \"\"\"Combine multiple ``CleaningStats`` objects (e.g., from parallel runs). Args: stats_list: Iterable of statistics objects to aggregate. Returns: Aggregate statistics across all provided objects. \"\"\" combined = cls () for stats in stats_list : combined += stats return combined summary \u00b6 summary ( include_filters = True ) Return a formatted string summarizing counters. Parameters: Name Type Description Default include_filters bool Whether to include per-filter breakdowns. True Returns: Type Description str Multiline string representation of the aggregated counters. Source code in chemrxn_cleaner/reporter.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def summary ( self , include_filters : bool = True ) -> str : \"\"\"Return a formatted string summarizing counters. Args: include_filters: Whether to include per-filter breakdowns. Returns: Multiline string representation of the aggregated counters. \"\"\" lines = [ f \"Input: { self . n_input } , output: { self . n_output } , \" f \"failed_parse: { self . n_failed_parse } \" ] if include_filters and self . per_filter : lines . append ( \"Per-filter:\" ) for name in sorted ( self . per_filter . keys ()): lines . append ( f \" { self . per_filter [ name ] } \" ) return \" \\n \" . join ( lines ) FilterStats dataclass \u00b6 Accumulates counts for an individual reaction filter. Attributes: Name Type Description name str Human-readable filter identifier. applied int Number of times the filter was evaluated. passed int Number of reactions accepted by the filter. failed int Number of reactions rejected by the filter. Source code in chemrxn_cleaner/reporter.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @dataclass class FilterStats : \"\"\"Accumulates counts for an individual reaction filter. Attributes: name: Human-readable filter identifier. applied: Number of times the filter was evaluated. passed: Number of reactions accepted by the filter. failed: Number of reactions rejected by the filter. \"\"\" name : str applied : int = 0 passed : int = 0 failed : int = 0 def format ( self ) -> str : \"\"\"Return a concise one-line summary of the counts.\"\"\" return ( f \" { self . name } : applied= { self . applied } , \" f \"passed= { self . passed } , failed= { self . failed } \" ) def __str__ ( self ) -> str : return self . format () format \u00b6 format () Return a concise one-line summary of the counts. Source code in chemrxn_cleaner/reporter.py 25 26 27 28 29 30 def format ( self ) -> str : \"\"\"Return a concise one-line summary of the counts.\"\"\" return ( f \" { self . name } : applied= { self . applied } , \" f \"passed= { self . passed } , failed= { self . failed } \" ) ReactionRecord dataclass \u00b6 Container for a single reaction instance. Attributes: Name Type Description reaction_id str Unique identifier for the reaction within a dataset. source str Origin of the reaction data (e.g., \"uspto\" , \"ord\" ). source_ref Optional [ str ] Reference such as DOI or patent number. source_file_path Optional [ str ] File path from which the record was loaded. reaction_smiles str Raw reaction SMILES string. reactants List [ str ] Reactant SMILES strings. reagents List [ str ] Reagent/agent SMILES strings. products List [ str ] Product SMILES strings. atom_mapping Optional [ str ] Optional atom-mapped reaction SMILES. reaction_class Optional [ str ] Optional reaction class label. procedure Dict [ str , Any ] Experimental procedure or flattened metadata. temperature_c Optional [ float ] Reaction temperature in Celsius. time_hours Optional [ float ] Reaction time in hours. pressure_bar Optional [ float ] Reaction pressure in bar. ph Optional [ float ] Observed or targeted pH. solvents List [ str ] List of solvent identifiers. catalysts List [ str ] List of catalysts. bases List [ str ] List of bases. additives List [ str ] List of other additives. atmosphere Optional [ str ] Reaction atmosphere description. scale_mmol Optional [ float ] Reaction scale in millimoles. yield_value Optional [ float ] Reported yield numeric value. yield_type YieldType Category describing how yield_value was measured. success Optional [ bool ] Optional boolean flag for reaction success. selectivity Optional [ float ] Selectivity metric value, if provided. selectivity_type Optional [ str ] Descriptor for the selectivity metric. is_balanced Optional [ bool ] Whether the reaction is atom-balanced. sanity_check_passed bool Indicates whether sanity checks passed. warnings List [ str ] Free-form warnings accumulated during processing. split Optional [ str ] Dataset split label (e.g., train/valid/test). extra_numeric Dict [ str , float ] Additional numeric metadata keyed by name. extra_categorical Dict [ str , str ] Additional categorical metadata keyed by name. extra_metadata Dict [ str , Any ] Unstructured metadata not captured elsewhere. Source code in chemrxn_cleaner/types.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 @dataclass class ReactionRecord : \"\"\"Container for a single reaction instance. Attributes: reaction_id: Unique identifier for the reaction within a dataset. source: Origin of the reaction data (e.g., ``\"uspto\"``, ``\"ord\"``). source_ref: Reference such as DOI or patent number. source_file_path: File path from which the record was loaded. reaction_smiles: Raw reaction SMILES string. reactants: Reactant SMILES strings. reagents: Reagent/agent SMILES strings. products: Product SMILES strings. atom_mapping: Optional atom-mapped reaction SMILES. reaction_class: Optional reaction class label. procedure: Experimental procedure or flattened metadata. temperature_c: Reaction temperature in Celsius. time_hours: Reaction time in hours. pressure_bar: Reaction pressure in bar. ph: Observed or targeted pH. solvents: List of solvent identifiers. catalysts: List of catalysts. bases: List of bases. additives: List of other additives. atmosphere: Reaction atmosphere description. scale_mmol: Reaction scale in millimoles. yield_value: Reported yield numeric value. yield_type: Category describing how ``yield_value`` was measured. success: Optional boolean flag for reaction success. selectivity: Selectivity metric value, if provided. selectivity_type: Descriptor for the selectivity metric. is_balanced: Whether the reaction is atom-balanced. sanity_check_passed: Indicates whether sanity checks passed. warnings: Free-form warnings accumulated during processing. split: Dataset split label (e.g., train/valid/test). extra_numeric: Additional numeric metadata keyed by name. extra_categorical: Additional categorical metadata keyed by name. extra_metadata: Unstructured metadata not captured elsewhere. \"\"\" # ---- Required identifiers / core representation ---- reaction_id : str = \"\" source : str = \"\" source_ref : Optional [ str ] = None source_file_path : Optional [ str ] = None reaction_smiles : str = \"\" # raw SMILES strings reactants : List [ str ] = field ( default_factory = list ) reagents : List [ str ] = field ( default_factory = list ) products : List [ str ] = field ( default_factory = list ) atom_mapping : Optional [ str ] = None reaction_class : Optional [ str ] = None # ---- Experimental conditions ---- temperature_c : Optional [ float ] = None time_hours : Optional [ float ] = None pressure_bar : Optional [ float ] = None ph : Optional [ float ] = None procedure : Dict [ str , Any ] = field ( default_factory = dict ) solvents : List [ str ] = field ( default_factory = list ) catalysts : List [ str ] = field ( default_factory = list ) bases : List [ str ] = field ( default_factory = list ) additives : List [ str ] = field ( default_factory = list ) atmosphere : Optional [ str ] = None scale_mmol : Optional [ float ] = None # ---- Outcomes (targets / labels) ---- yield_value : Optional [ float ] = None yield_type : YieldType = YieldType . NONE success : Optional [ bool ] = None # ---- selectivity ---- selectivity : Optional [ float ] = None selectivity_type : Optional [ str ] = None # ---- Data-quality / bookkeeping ---- is_balanced : Optional [ bool ] = None sanity_check_passed : bool = True warnings : List [ str ] = field ( default_factory = list ) # Dataset management only \u2013 e.g. \u201ctrain/valid/test/time_split\u201d split : Optional [ str ] = None # ---- Extension hooks ---- extra_numeric : Dict [ str , float ] = field ( default_factory = dict ) extra_categorical : Dict [ str , str ] = field ( default_factory = dict ) extra_metadata : Dict [ str , Any ] = field ( default_factory = dict ) def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Return a plain-Python representation that is JSON serializable. Returns: Dictionary containing shallow copies of all fields suitable for JSON serialization. \"\"\" return { \"reaction_id\" : self . reaction_id , \"source\" : self . source , \"source_ref\" : self . source_ref , \"source_file_path\" : self . source_file_path , \"reaction_smiles\" : self . reaction_smiles , \"reactants\" : list ( self . reactants ), \"reagents\" : list ( self . reagents ), \"products\" : list ( self . products ), \"atom_mapping\" : self . atom_mapping , \"reaction_class\" : self . reaction_class , \"procedure\" : dict ( self . procedure ), \"temperature_c\" : self . temperature_c , \"time_hours\" : self . time_hours , \"pressure_bar\" : self . pressure_bar , \"ph\" : self . ph , \"solvents\" : list ( self . solvents ), \"catalysts\" : list ( self . catalysts ), \"bases\" : list ( self . bases ), \"additives\" : list ( self . additives ), \"atmosphere\" : self . atmosphere , \"scale_mmol\" : self . scale_mmol , \"yield_value\" : self . yield_value , \"yield_type\" : self . yield_type . value if self . yield_type else None , \"success\" : self . success , \"selectivity\" : self . selectivity , \"selectivity_type\" : self . selectivity_type , \"is_balanced\" : self . is_balanced , \"sanity_check_passed\" : self . sanity_check_passed , \"warnings\" : list ( self . warnings ), \"split\" : self . split , \"extra_numeric\" : dict ( self . extra_numeric ), \"extra_categorical\" : dict ( self . extra_categorical ), \"extra_metadata\" : dict ( self . extra_metadata or {}), } @classmethod def from_dict ( cls , data : Dict [ str , Any ]) -> \"ReactionRecord\" : \"\"\"Construct a ``ReactionRecord`` from a dictionary payload. Args: data: Mapping produced by ``to_dict`` or a similarly structured dictionary. Returns: A populated ``ReactionRecord`` instance. \"\"\" yield_type_value = data . get ( \"yield_type\" ) or YieldType . NONE if isinstance ( yield_type_value , str ): try : yield_type_enum = YieldType ( yield_type_value ) except ValueError : yield_type_enum = YieldType . NONE else : yield_type_enum = yield_type_value return cls ( reaction_id = data . get ( \"reaction_id\" , \"\" ), source = data . get ( \"source\" , \"\" ), source_ref = data . get ( \"source_ref\" ), source_file_path = data . get ( \"source_file_path\" ), reaction_smiles = data . get ( \"reaction_smiles\" ) or data . get ( \"raw\" , \"\" ), reactants = list ( data . get ( \"reactants\" , []) or []), reagents = list ( data . get ( \"reagents\" , []) or []), products = list ( data . get ( \"products\" , []) or []), atom_mapping = data . get ( \"atom_mapping\" ), reaction_class = data . get ( \"reaction_class\" ), procedure = dict ( data . get ( \"procedure\" , {}) or {}), temperature_c = data . get ( \"temperature_c\" ), time_hours = data . get ( \"time_hours\" ), pressure_bar = data . get ( \"pressure_bar\" ), ph = data . get ( \"ph\" ), solvents = list ( data . get ( \"solvents\" , []) or []), catalysts = list ( data . get ( \"catalysts\" , []) or []), bases = list ( data . get ( \"bases\" , []) or []), additives = list ( data . get ( \"additives\" , []) or []), atmosphere = data . get ( \"atmosphere\" ), scale_mmol = data . get ( \"scale_mmol\" ), yield_value = data . get ( \"yield_value\" ), yield_type = yield_type_enum , success = data . get ( \"success\" ), selectivity = data . get ( \"selectivity\" ), selectivity_type = data . get ( \"selectivity_type\" ), is_balanced = data . get ( \"is_balanced\" ), sanity_check_passed = data . get ( \"sanity_check_passed\" , True ), warnings = list ( data . get ( \"warnings\" , []) or []), split = data . get ( \"split\" ), extra_numeric = dict ( data . get ( \"extra_numeric\" , {}) or {}), extra_categorical = dict ( data . get ( \"extra_categorical\" , {}) or {}), extra_metadata = cls . _merge_extra_metadata ( data ), ) @classmethod def _merge_extra_metadata ( cls , data : Dict [ str , Any ]) -> Dict [ str , Any ]: \"\"\"Combine explicit extra metadata with any unknown top-level keys.\"\"\" base_meta = data . get ( \"extra_metadata\" ) or {} if isinstance ( base_meta , dict ): extra_meta = dict ( base_meta ) else : try : extra_meta = dict ( base_meta ) except Exception : extra_meta = {} meta_alias = data . get ( \"meta\" ) if isinstance ( meta_alias , dict ): extra_meta . update ( meta_alias ) known_keys = set ( cls . __dataclass_fields__ . keys ()) | { \"meta\" } for key , value in data . items (): if key not in known_keys and key not in extra_meta : extra_meta [ key ] = value return extra_meta def __post_init__ ( self ) -> None : \"\"\"Ensure optional mapping fields default to empty dictionaries.\"\"\" if self . extra_metadata is None : self . extra_metadata = {} if self . procedure is None : self . procedure = {} def show ( self , size : tuple [ int , int ] = ( 2400 , 600 ), jupyter : bool = True , with_meta : bool = True , show_atom_map_numbers : bool = False , ): \"\"\"Visualize the reaction using RDKit. Args: size: Tuple of pixel dimensions for the rendered image. jupyter: When True, display inline using IPython display hooks. with_meta: When True, show ``extra_metadata`` alongside the image. show_atom_map_numbers: When True, keep atom-map numbers in the depiction; when False, they are stripped before drawing. \"\"\" from rdkit.Chem import Draw , rdChemReactions rxn_smiles = self . reaction_smiles rxn = rdChemReactions . ReactionFromSmarts ( rxn_smiles , useSmiles = True ) if not show_atom_map_numbers : # Remove atom-map numbers to avoid numbered atom labels in depictions. for mol in ( list ( rxn . GetReactants ()) + list ( rxn . GetProducts ()) + list ( rxn . GetAgents ()) ): for atom in mol . GetAtoms (): if atom . HasProp ( \"molAtomMapNumber\" ): atom . ClearProp ( \"molAtomMapNumber\" ) img = Draw . ReactionToImage ( rxn , subImgSize = ( size [ 0 ] // 3 , size [ 1 ])) if jupyter : try : from IPython.display import HTML , display except ImportError : # pragma: no cover - optional dependency jupyter = False else : display ( img ) if with_meta and self . extra_metadata : rows = \"\" . join ( f \"<tr><th> { k } </th><td> { v } </td></tr>\" for k , v in self . extra_metadata . items () ) display ( HTML ( \"<table border='1' style='border-collapse:collapse;'>\" f \" { rows } </table>\" ) ) if not jupyter : try : img . show () except Exception as exc : # pragma: no cover - environment specific print ( \"Unable to open the image viewer.\" \" Consider running in a Jupyter environment.\" ) print ( f \"Original error: { exc } \" ) if with_meta and self . extra_metadata : print ( \"Metadata:\" ) for k , v in self . extra_metadata . items (): print ( f \" { k } : { v } \" ) return img to_dict \u00b6 to_dict () Return a plain-Python representation that is JSON serializable. Returns: Type Description Dict [ str , Any ] Dictionary containing shallow copies of all fields suitable for JSON Dict [ str , Any ] serialization. Source code in chemrxn_cleaner/types.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Return a plain-Python representation that is JSON serializable. Returns: Dictionary containing shallow copies of all fields suitable for JSON serialization. \"\"\" return { \"reaction_id\" : self . reaction_id , \"source\" : self . source , \"source_ref\" : self . source_ref , \"source_file_path\" : self . source_file_path , \"reaction_smiles\" : self . reaction_smiles , \"reactants\" : list ( self . reactants ), \"reagents\" : list ( self . reagents ), \"products\" : list ( self . products ), \"atom_mapping\" : self . atom_mapping , \"reaction_class\" : self . reaction_class , \"procedure\" : dict ( self . procedure ), \"temperature_c\" : self . temperature_c , \"time_hours\" : self . time_hours , \"pressure_bar\" : self . pressure_bar , \"ph\" : self . ph , \"solvents\" : list ( self . solvents ), \"catalysts\" : list ( self . catalysts ), \"bases\" : list ( self . bases ), \"additives\" : list ( self . additives ), \"atmosphere\" : self . atmosphere , \"scale_mmol\" : self . scale_mmol , \"yield_value\" : self . yield_value , \"yield_type\" : self . yield_type . value if self . yield_type else None , \"success\" : self . success , \"selectivity\" : self . selectivity , \"selectivity_type\" : self . selectivity_type , \"is_balanced\" : self . is_balanced , \"sanity_check_passed\" : self . sanity_check_passed , \"warnings\" : list ( self . warnings ), \"split\" : self . split , \"extra_numeric\" : dict ( self . extra_numeric ), \"extra_categorical\" : dict ( self . extra_categorical ), \"extra_metadata\" : dict ( self . extra_metadata or {}), } from_dict classmethod \u00b6 from_dict ( data ) Construct a ReactionRecord from a dictionary payload. Parameters: Name Type Description Default data Dict [ str , Any ] Mapping produced by to_dict or a similarly structured dictionary. required Returns: Type Description ReactionRecord A populated ReactionRecord instance. Source code in chemrxn_cleaner/types.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 @classmethod def from_dict ( cls , data : Dict [ str , Any ]) -> \"ReactionRecord\" : \"\"\"Construct a ``ReactionRecord`` from a dictionary payload. Args: data: Mapping produced by ``to_dict`` or a similarly structured dictionary. Returns: A populated ``ReactionRecord`` instance. \"\"\" yield_type_value = data . get ( \"yield_type\" ) or YieldType . NONE if isinstance ( yield_type_value , str ): try : yield_type_enum = YieldType ( yield_type_value ) except ValueError : yield_type_enum = YieldType . NONE else : yield_type_enum = yield_type_value return cls ( reaction_id = data . get ( \"reaction_id\" , \"\" ), source = data . get ( \"source\" , \"\" ), source_ref = data . get ( \"source_ref\" ), source_file_path = data . get ( \"source_file_path\" ), reaction_smiles = data . get ( \"reaction_smiles\" ) or data . get ( \"raw\" , \"\" ), reactants = list ( data . get ( \"reactants\" , []) or []), reagents = list ( data . get ( \"reagents\" , []) or []), products = list ( data . get ( \"products\" , []) or []), atom_mapping = data . get ( \"atom_mapping\" ), reaction_class = data . get ( \"reaction_class\" ), procedure = dict ( data . get ( \"procedure\" , {}) or {}), temperature_c = data . get ( \"temperature_c\" ), time_hours = data . get ( \"time_hours\" ), pressure_bar = data . get ( \"pressure_bar\" ), ph = data . get ( \"ph\" ), solvents = list ( data . get ( \"solvents\" , []) or []), catalysts = list ( data . get ( \"catalysts\" , []) or []), bases = list ( data . get ( \"bases\" , []) or []), additives = list ( data . get ( \"additives\" , []) or []), atmosphere = data . get ( \"atmosphere\" ), scale_mmol = data . get ( \"scale_mmol\" ), yield_value = data . get ( \"yield_value\" ), yield_type = yield_type_enum , success = data . get ( \"success\" ), selectivity = data . get ( \"selectivity\" ), selectivity_type = data . get ( \"selectivity_type\" ), is_balanced = data . get ( \"is_balanced\" ), sanity_check_passed = data . get ( \"sanity_check_passed\" , True ), warnings = list ( data . get ( \"warnings\" , []) or []), split = data . get ( \"split\" ), extra_numeric = dict ( data . get ( \"extra_numeric\" , {}) or {}), extra_categorical = dict ( data . get ( \"extra_categorical\" , {}) or {}), extra_metadata = cls . _merge_extra_metadata ( data ), ) _merge_extra_metadata classmethod \u00b6 _merge_extra_metadata ( data ) Combine explicit extra metadata with any unknown top-level keys. Source code in chemrxn_cleaner/types.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 @classmethod def _merge_extra_metadata ( cls , data : Dict [ str , Any ]) -> Dict [ str , Any ]: \"\"\"Combine explicit extra metadata with any unknown top-level keys.\"\"\" base_meta = data . get ( \"extra_metadata\" ) or {} if isinstance ( base_meta , dict ): extra_meta = dict ( base_meta ) else : try : extra_meta = dict ( base_meta ) except Exception : extra_meta = {} meta_alias = data . get ( \"meta\" ) if isinstance ( meta_alias , dict ): extra_meta . update ( meta_alias ) known_keys = set ( cls . __dataclass_fields__ . keys ()) | { \"meta\" } for key , value in data . items (): if key not in known_keys and key not in extra_meta : extra_meta [ key ] = value return extra_meta show \u00b6 show ( size = ( 2400 , 600 ), jupyter = True , with_meta = True , show_atom_map_numbers = False ) Visualize the reaction using RDKit. Parameters: Name Type Description Default size tuple [ int , int ] Tuple of pixel dimensions for the rendered image. (2400, 600) jupyter bool When True, display inline using IPython display hooks. True with_meta bool When True, show extra_metadata alongside the image. True show_atom_map_numbers bool When True, keep atom-map numbers in the depiction; when False, they are stripped before drawing. False Source code in chemrxn_cleaner/types.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 def show ( self , size : tuple [ int , int ] = ( 2400 , 600 ), jupyter : bool = True , with_meta : bool = True , show_atom_map_numbers : bool = False , ): \"\"\"Visualize the reaction using RDKit. Args: size: Tuple of pixel dimensions for the rendered image. jupyter: When True, display inline using IPython display hooks. with_meta: When True, show ``extra_metadata`` alongside the image. show_atom_map_numbers: When True, keep atom-map numbers in the depiction; when False, they are stripped before drawing. \"\"\" from rdkit.Chem import Draw , rdChemReactions rxn_smiles = self . reaction_smiles rxn = rdChemReactions . ReactionFromSmarts ( rxn_smiles , useSmiles = True ) if not show_atom_map_numbers : # Remove atom-map numbers to avoid numbered atom labels in depictions. for mol in ( list ( rxn . GetReactants ()) + list ( rxn . GetProducts ()) + list ( rxn . GetAgents ()) ): for atom in mol . GetAtoms (): if atom . HasProp ( \"molAtomMapNumber\" ): atom . ClearProp ( \"molAtomMapNumber\" ) img = Draw . ReactionToImage ( rxn , subImgSize = ( size [ 0 ] // 3 , size [ 1 ])) if jupyter : try : from IPython.display import HTML , display except ImportError : # pragma: no cover - optional dependency jupyter = False else : display ( img ) if with_meta and self . extra_metadata : rows = \"\" . join ( f \"<tr><th> { k } </th><td> { v } </td></tr>\" for k , v in self . extra_metadata . items () ) display ( HTML ( \"<table border='1' style='border-collapse:collapse;'>\" f \" { rows } </table>\" ) ) if not jupyter : try : img . show () except Exception as exc : # pragma: no cover - environment specific print ( \"Unable to open the image viewer.\" \" Consider running in a Jupyter environment.\" ) print ( f \"Original error: { exc } \" ) if with_meta and self . extra_metadata : print ( \"Metadata:\" ) for k , v in self . extra_metadata . items (): print ( f \" { k } : { v } \" ) return img clean_and_canonicalize \u00b6 clean_and_canonicalize ( rxn_smiles_list , filters = None , drop_failed_parse = True , strict = True , isomeric = True ) Clean reactions and canonicalize all SMILES in one pass. Parameters: Name Type Description Default rxn_smiles_list Iterable [ ReactionRecord ] Iterable of ReactionRecords to clean. required filters Optional [ List [ ReactionFilter ]] Optional list of filter predicates; falls back to default_filters() when None. None drop_failed_parse bool Whether to drop reactions that fail parsing rather than raising. True strict bool Enforce exactly three > parts in reaction SMILES when True. True isomeric bool Preserve isomeric information during canonicalization. True Returns: Type Description List [ ReactionRecord ] Reaction records with canonicalized reactants, reagents, and products. Source code in chemrxn_cleaner/cleaner.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 def clean_and_canonicalize ( rxn_smiles_list : Iterable [ ReactionRecord ], filters : Optional [ List [ ReactionFilter ]] = None , drop_failed_parse : bool = True , strict : bool = True , isomeric : bool = True , ) -> List [ ReactionRecord ]: \"\"\"Clean reactions and canonicalize all SMILES in one pass. Args: rxn_smiles_list: Iterable of ReactionRecords to clean. filters: Optional list of filter predicates; falls back to ``default_filters()`` when None. drop_failed_parse: Whether to drop reactions that fail parsing rather than raising. strict: Enforce exactly three ``>`` parts in reaction SMILES when True. isomeric: Preserve isomeric information during canonicalization. Returns: Reaction records with canonicalized reactants, reagents, and products. \"\"\" cleaned = clean_reactions ( rxn_smiles_list = rxn_smiles_list , filters = filters , drop_failed_parse = drop_failed_parse , strict = strict , ) logger . info ( \"Canonicalizing %d reactions (isomeric= %s )\" , len ( cleaned ), isomeric ) canon_records : List [ ReactionRecord ] = [] for rec in cleaned : try : canon_records . append ( canonicalize_reaction ( rec , isomeric = isomeric )) except Exception : logger . exception ( \"Canonicalization failed for reaction %s \" , rec . reaction_id or rec . reaction_smiles or \"<unknown>\" , ) raise return canon_records clean_reactions \u00b6 clean_reactions ( rxn_smiles_list , filters = None , drop_failed_parse = True , strict = True ) Parse, validate, and filter reaction records. Parameters: Name Type Description Default rxn_smiles_list Iterable [ ReactionRecord ] Iterable of reactions. Empty reactant/reagent/product fields are parsed from reaction_smiles when present. required filters Optional [ List [ ReactionFilter ]] Optional list of predicate callables; defaults to default_filters() when omitted. None drop_failed_parse bool When True, quietly drop reactions that cannot be parsed; when False, propagate the parsing error. True strict bool Passed to parse_reaction_smiles ; enforces three '>' parts when True, otherwise pads missing parts. True Returns: Type Description List [ ReactionRecord ] Cleaned reactions that passed all filters. Source code in chemrxn_cleaner/cleaner.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 def clean_reactions ( rxn_smiles_list : Iterable [ ReactionRecord ], filters : Optional [ List [ ReactionFilter ]] = None , drop_failed_parse : bool = True , strict : bool = True , ) -> List [ ReactionRecord ]: \"\"\"Parse, validate, and filter reaction records. Args: rxn_smiles_list: Iterable of reactions. Empty reactant/reagent/product fields are parsed from ``reaction_smiles`` when present. filters: Optional list of predicate callables; defaults to ``default_filters()`` when omitted. drop_failed_parse: When True, quietly drop reactions that cannot be parsed; when False, propagate the parsing error. strict: Passed to ``parse_reaction_smiles``; enforces three '>' parts when True, otherwise pads missing parts. Returns: Cleaned reactions that passed all filters. \"\"\" cleaned , _ = _clean_reactions_internal ( rxn_smiles_list = rxn_smiles_list , filters = filters , drop_failed_parse = drop_failed_parse , strict = strict , collect_stats = False , ) return cleaned clean_reactions_with_report \u00b6 clean_reactions_with_report ( rxn_smiles_list , filters = None , drop_failed_parse = True , strict = True ) Run the cleaning pipeline and return results plus statistics. Parameters: Name Type Description Default rxn_smiles_list Iterable [ ReactionRecord ] Iterable of input reactions to process. required filters Optional [ List [ ReactionFilter ]] Optional list of filters to apply; defaults to default_filters() when omitted. None drop_failed_parse bool Whether to drop reactions that cannot be parsed instead of raising. True strict bool When True, require reaction SMILES to contain three sections. True Returns: Type Description Tuple [ List [ ReactionRecord ], CleaningStats ] A tuple of (cleaned_reactions, cleaning_stats) . Source code in chemrxn_cleaner/cleaner.py 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 def clean_reactions_with_report ( rxn_smiles_list : Iterable [ ReactionRecord ], filters : Optional [ List [ ReactionFilter ]] = None , drop_failed_parse : bool = True , strict : bool = True , ) -> Tuple [ List [ ReactionRecord ], CleaningStats ]: \"\"\"Run the cleaning pipeline and return results plus statistics. Args: rxn_smiles_list: Iterable of input reactions to process. filters: Optional list of filters to apply; defaults to ``default_filters()`` when omitted. drop_failed_parse: Whether to drop reactions that cannot be parsed instead of raising. strict: When True, require reaction SMILES to contain three sections. Returns: A tuple of ``(cleaned_reactions, cleaning_stats)``. \"\"\" return _clean_reactions_internal ( rxn_smiles_list = rxn_smiles_list , filters = filters , drop_failed_parse = drop_failed_parse , strict = strict , collect_stats = True , ) all_molecules_valid \u00b6 all_molecules_valid ( record ) Verify that all reaction molecules are valid SMILES. Parameters: Name Type Description Default record ReactionRecord Reaction to evaluate. required Returns: Type Description bool True when every reactant, reagent, and product SMILES parses in RDKit. Source code in chemrxn_cleaner/filters.py 109 110 111 112 113 114 115 116 117 118 119 120 121 def all_molecules_valid ( record : ReactionRecord ) -> bool : \"\"\"Verify that all reaction molecules are valid SMILES. Args: record: Reaction to evaluate. Returns: True when every reactant, reagent, and product SMILES parses in RDKit. \"\"\" for s in _iter_all_smiles ( record ): if not _is_valid_smiles ( s ): return False return True default_filters \u00b6 default_filters () Return the default list of reaction filters. The defaults ensure at least one product is present and that all SMILES strings are valid RDKit molecules. Returns: Type Description List [ ReactionFilter ] List of basic ReactionFilter callables. Source code in chemrxn_cleaner/filters.py 275 276 277 278 279 280 281 282 283 284 285 286 287 def default_filters () -> List [ ReactionFilter ]: \"\"\"Return the default list of reaction filters. The defaults ensure at least one product is present and that all SMILES strings are valid RDKit molecules. Returns: List of basic ReactionFilter callables. \"\"\" return [ has_product , all_molecules_valid , ] element_filter \u00b6 element_filter ( allowList = None , forbidList = None ) Build a ReactionFilter enforcing per-role element rules. For each reactant, reagent, and product molecule, the generated filter: 1) parses the SMILES with RDKit, 2) checks membership in allowList when provided, and 3) rejects any atom that appears in forbidList . Constraints are evaluated per role; missing rules skip that check. Parameters: Name Type Description Default allowList ElementFilterRule | None Allowed element symbols for each role. None disables allow-list filtering. None forbidList ElementFilterRule | None Forbidden element symbols for each role. None disables forbid-list filtering. None Returns: Type Description ReactionFilter ReactionFilter predicate implementing the configured constraints. Raises: Type Description ValueError If element symbols are empty or invalid. Source code in chemrxn_cleaner/filters.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def element_filter ( allowList : ElementFilterRule | None = None , forbidList : ElementFilterRule | None = None , ) -> ReactionFilter : \"\"\"Build a ReactionFilter enforcing per-role element rules. For each reactant, reagent, and product molecule, the generated filter: 1) parses the SMILES with RDKit, 2) checks membership in ``allowList`` when provided, and 3) rejects any atom that appears in ``forbidList``. Constraints are evaluated per role; missing rules skip that check. Args: allowList: Allowed element symbols for each role. ``None`` disables allow-list filtering. forbidList: Forbidden element symbols for each role. ``None`` disables forbid-list filtering. Returns: ReactionFilter predicate implementing the configured constraints. Raises: ValueError: If element symbols are empty or invalid. \"\"\" allowed_reactants = _normalize_element_list ( allowList . reactantElements if allowList else None ) allowed_reagents = _normalize_element_list ( allowList . reagentElements if allowList else None ) allowed_products = _normalize_element_list ( allowList . productElements if allowList else None ) forbidden_reactants = _normalize_element_list ( forbidList . reactantElements if forbidList else None ) forbidden_reagents = _normalize_element_list ( forbidList . reagentElements if forbidList else None ) forbidden_products = _normalize_element_list ( forbidList . productElements if forbidList else None ) def _check_molecules ( smiles_list : Iterable [ str ], allowed : Set [ str ] | None , forbidden : Set [ str ] | None , ) -> bool : \"\"\"Validate molecules against allowed/forbidden element sets. Args: smiles_list: SMILES strings to validate. allowed: Elements permitted for the given role, or ``None`` to skip. forbidden: Elements to reject for the given role, or ``None`` to skip. Returns: True if all molecules satisfy both element constraints. \"\"\" for smile in smiles_list : mol = Chem . MolFromSmiles ( smile ) if mol is None : return False for atom in mol . GetAtoms (): symbol = atom . GetSymbol () if allowed is not None and symbol not in allowed : return False if forbidden is not None and symbol in forbidden : return False return True def _filter ( record : ReactionRecord ) -> bool : return ( _check_molecules ( record . reactants , allowed_reactants , forbidden_reactants ) and _check_molecules ( record . reagents , allowed_reagents , forbidden_reagents ) and _check_molecules ( record . products , allowed_products , forbidden_products ) ) _filter . __name__ = \"element_filter\" return _filter has_product \u00b6 has_product ( record ) Check whether the reaction contains at least one product molecule. Parameters: Name Type Description Default record ReactionRecord Reaction to evaluate. required Returns: Type Description bool True when at least one product SMILES is present. Source code in chemrxn_cleaner/filters.py 97 98 99 100 101 102 103 104 105 106 def has_product ( record : ReactionRecord ) -> bool : \"\"\"Check whether the reaction contains at least one product molecule. Args: record: Reaction to evaluate. Returns: True when at least one product SMILES is present. \"\"\" return len ( record . products ) > 0 max_smiles_length \u00b6 max_smiles_length ( max_len ) Build a filter that enforces a maximum SMILES length. Parameters: Name Type Description Default max_len int Maximum allowed character length for any SMILES string. required Returns: Type Description ReactionFilter ReactionFilter predicate that rejects reactions containing longer SMILES. Source code in chemrxn_cleaner/filters.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def max_smiles_length ( max_len : int ) -> ReactionFilter : \"\"\"Build a filter that enforces a maximum SMILES length. Args: max_len: Maximum allowed character length for any SMILES string. Returns: ReactionFilter predicate that rejects reactions containing longer SMILES. \"\"\" def _filter ( record : ReactionRecord ) -> bool : \"\"\"Return True when all SMILES strings are within the length limit. Args: record: Reaction to evaluate. Returns: True if every SMILES length is less than or equal to ``max_len``. \"\"\" for s in _iter_all_smiles ( record ): if len ( s ) > max_len : return False return True _filter . __name__ = f \"max_smiles_length( { max_len } )\" return _filter meta_filter \u00b6 meta_filter ( predicate ) Create a filter that tests metadata via a user predicate. Parameters: Name Type Description Default predicate Callable [[ Dict [ str , Any ]], bool ] Callable that receives extra_metadata and returns True to keep the reaction or False to drop it. required Returns: Type Description ReactionFilter ReactionFilter wrapping the predicate. Source code in chemrxn_cleaner/filters.py 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 def meta_filter ( predicate : Callable [[ Dict [ str , Any ]], bool ]) -> ReactionFilter : \"\"\"Create a filter that tests metadata via a user predicate. Args: predicate: Callable that receives ``extra_metadata`` and returns True to keep the reaction or False to drop it. Returns: ReactionFilter wrapping the predicate. \"\"\" def _filter ( record : ReactionRecord ) -> bool : \"\"\"Return True when the predicate accepts the record metadata. Args: record: Reaction to evaluate. Returns: Result of the predicate; False when the predicate raises. \"\"\" meta = record . extra_metadata or {} try : return predicate ( meta ) except Exception : # Treat predicate errors as a failed filter match return False pred_name = getattr ( predicate , \"__name__\" , predicate . __class__ . __name__ ) _filter . __name__ = f \"meta_filter( { pred_name } )\" return _filter export_reaction_records \u00b6 export_reaction_records ( records , path , * , fmt = None , indent = 2 ) Serialize reactions to the provided path as JSON or CSV. Parameters: Name Type Description Default records Sequence [ ReactionRecord ] Reaction records to serialize. required path str | Path Destination path for the file. required fmt str | None Output format; \"json\" or \"csv\" . When omitted, the format is inferred from the file extension. None indent int Indentation level for JSON output (ignored for CSV). 2 Source code in chemrxn_cleaner/io/writer.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def export_reaction_records ( records : Sequence [ ReactionRecord ], path : str | Path , * , fmt : str | None = None , indent : int = 2 , ) -> None : \"\"\"Serialize reactions to the provided path as JSON or CSV. Args: records: Reaction records to serialize. path: Destination path for the file. fmt: Output format; ``\"json\"`` or ``\"csv\"``. When omitted, the format is inferred from the file extension. indent: Indentation level for JSON output (ignored for CSV). \"\"\" out_path = _ensure_path ( path ) resolved_fmt = ( fmt or out_path . suffix . lstrip ( \".\" )) . lower () if not resolved_fmt : raise ValueError ( \"File format not provided; supply fmt or a .json/.csv path.\" ) if resolved_fmt == \"json\" : _write_json ( records , out_path , indent = indent ) elif resolved_fmt == \"csv\" : _write_csv ( records , out_path ) else : raise ValueError ( f \"Unsupported export format ' { resolved_fmt } '. Use 'json' or 'csv'.\" ) get_input_format \u00b6 get_input_format ( name ) Retrieve the loader registered for the given name. Parameters: Name Type Description Default name str Format name used during registration (e.g., \"uspto\" ). required Returns: Type Description InputLoader The loader callable for the specified format. Raises: Type Description InputFormatError If the format is not registered. Source code in chemrxn_cleaner/io/loader_registry.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 def get_input_format ( name : str ) -> InputLoader : \"\"\"Retrieve the loader registered for the given name. Args: name: Format name used during registration (e.g., ``\"uspto\"``). Returns: The loader callable for the specified format. Raises: InputFormatError: If the format is not registered. \"\"\" key = name . strip () . lower () try : return _INPUT_FORMAT_REGISTRY [ key ] except KeyError : available = \", \" . join ( sorted ( _INPUT_FORMAT_REGISTRY . keys ())) or \"<none>\" raise InputFormatError ( f \"Unknown input format ' { key } '. Available formats: { available } \" ) from None load_reactions \u00b6 load_reactions ( source : str , * , fmt : Literal [ 'uspto' ], keep_meta : bool = False , strip_atom_mapping : bool = False ) -> List [ ReactionRecord ] load_reactions ( source : str , * , fmt : Literal [ 'ord' ], generate_if_missing : bool = True , allow_incomplete : bool = True , canonical : bool = True , meta_extractor : Optional [ Callable [[ Any ], Dict [ str , Any ]]] = None , strip_atom_mapping : bool = False ) -> List [ ReactionRecord ] load_reactions ( source : str , * , fmt : Literal [ 'csv' ], reactant_columns : Sequence [ str ] = (), product_columns : Sequence [ str ] = (), reagent_columns : Optional [ Sequence [ str ]] = None , reaction_smiles_column : Optional [ str ] = None , delimiter : str = ',' , skip_lines : int = 0 , mapper : Optional [ Callable [[ ReactionRecord , Dict [ str , Any ]], Optional [ ReactionRecord ]]] = None , strip_atom_mapping : bool = False ) -> List [ ReactionRecord ] load_reactions ( source : str , * , fmt : Literal [ 'json' ], mapper : Callable [[ Any ], Optional [ ReactionRecord ]], strip_atom_mapping : bool = False ) -> List [ ReactionRecord ] load_reactions ( source : Any , * , fmt : str , ** kwargs : Any ) -> List [ ReactionRecord ] load_reactions ( source , * , fmt , ** kwargs ) Parse an external data source using a registered format loader. Parameters: Name Type Description Default source Any External data source such as a file path, DataFrame, or list. required fmt str Registered input format name (e.g., \"uspto\" , \"ord\" , \"csv\" ). required **kwargs Any Extra arguments forwarded to the selected loader. {} Returns: Type Description List [ ReactionRecord ] List of ReactionRecord instances produced by the loader. Source code in chemrxn_cleaner/io/loader_registry.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 def load_reactions ( source : Any , * , fmt : str , ** kwargs : Any , ) -> List [ ReactionRecord ]: \"\"\"Parse an external data source using a registered format loader. Args: source: External data source such as a file path, DataFrame, or list. fmt: Registered input format name (e.g., ``\"uspto\"``, ``\"ord\"``, ``\"csv\"``). **kwargs: Extra arguments forwarded to the selected loader. Returns: List of ``ReactionRecord`` instances produced by the loader. \"\"\" logger . info ( \"Loading reactions using format ' %s '\" , fmt ) loader = get_input_format ( fmt ) return list ( loader ( source , ** kwargs )) register_input_format \u00b6 register_input_format ( name , loader , * , overwrite = False ) Register a new input format. Parameters: Name Type Description Default name str Input format name (e.g., \"uspto\" , \"ord\" , \"csv\" ). Prefer lowercase with underscores. required loader InputLoader Callable with signature loader(source, **kwargs) returning an iterable of ReactionRecord instances. required overwrite bool When True, replace any existing loader registered under the same name. False Raises: Type Description InputFormatError If the name already exists and overwrite is False or the loader does not satisfy the protocol. Source code in chemrxn_cleaner/io/loader_registry.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def register_input_format ( name : str , loader : InputLoader , * , overwrite : bool = False , ) -> None : \"\"\"Register a new input format. Args: name: Input format name (e.g., ``\"uspto\"``, ``\"ord\"``, ``\"csv\"``). Prefer lowercase with underscores. loader: Callable with signature ``loader(source, **kwargs)`` returning an iterable of ``ReactionRecord`` instances. overwrite: When True, replace any existing loader registered under the same name. Raises: InputFormatError: If the name already exists and ``overwrite`` is False or the loader does not satisfy the protocol. \"\"\" key = name . strip () . lower () if not key : raise InputFormatError ( \"Input format name must be a non-empty string.\" ) if key in _INPUT_FORMAT_REGISTRY and not overwrite : raise InputFormatError ( f \"Input format ' { key } ' already exists. Use overwrite=True to replace it.\" ) if not isinstance ( loader , InputLoader ): # Type check is intentionally loose but can help catch issues early raise InputFormatError ( f \"Loader for format ' { key } ' does not match InputLoader protocol. \" f \"Expected callable(source, **kwargs) -> Iterable[ReactionRecord].\" ) _INPUT_FORMAT_REGISTRY [ key ] = loader logger . debug ( \"Registered input format ' %s ' (overwrite= %s )\" , key , overwrite ) records_to_dataframe \u00b6 records_to_dataframe ( records ) Convert reaction records into a pandas.DataFrame . Parameters: Name Type Description Default records Iterable [ ReactionRecord ] Iterable of ReactionRecord instances. required Returns: Type Description DataFrame DataFrame containing flattened record fields; list fields are joined DataFrame with \" | \" separators for readability. Source code in chemrxn_cleaner/ml/utils.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def records_to_dataframe ( records : Iterable [ ReactionRecord ]) -> pd . DataFrame : \"\"\"Convert reaction records into a ``pandas.DataFrame``. Args: records: Iterable of ``ReactionRecord`` instances. Returns: DataFrame containing flattened record fields; list fields are joined with ``\" | \"`` separators for readability. \"\"\" rows = [] for r in records : row = asdict ( r ) # Flatten list fields to simple strings for CSV (optional) for key , value in list ( row . items ()): if isinstance ( value , list ): row [ key ] = \" | \" . join ( value ) rows . append ( row ) return pd . DataFrame ( rows ) train_valid_test_split \u00b6 train_valid_test_split ( records , train_ratio = 0.8 , valid_ratio = 0.1 , seed = 0 ) Randomly split records into train/valid/test partitions. Parameters: Name Type Description Default records List [ ReactionRecord ] Dataset to split. required train_ratio float Fraction of examples allocated to the training set. 0.8 valid_ratio float Fraction allocated to the validation set. 0.1 seed int Random seed for deterministic shuffling. 0 Returns: Type Description Tuple [ List [ ReactionRecord ], List [ ReactionRecord ], List [ ReactionRecord ]] Tuple of (train, valid, test) record lists. Source code in chemrxn_cleaner/ml/utils.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def train_valid_test_split ( records : List [ ReactionRecord ], train_ratio : float = 0.8 , valid_ratio : float = 0.1 , seed : int = 0 , ) -> Tuple [ List [ ReactionRecord ], List [ ReactionRecord ], List [ ReactionRecord ]]: \"\"\"Randomly split records into train/valid/test partitions. Args: records: Dataset to split. train_ratio: Fraction of examples allocated to the training set. valid_ratio: Fraction allocated to the validation set. seed: Random seed for deterministic shuffling. Returns: Tuple of ``(train, valid, test)`` record lists. \"\"\" rng = random . Random ( seed ) idxs = list ( range ( len ( records ))) rng . shuffle ( idxs ) n = len ( records ) n_train = int ( n * train_ratio ) n_valid = int ( n * valid_ratio ) train_idx = idxs [: n_train ] valid_idx = idxs [ n_train : n_train + n_valid ] test_idx = idxs [ n_train + n_valid :] def pick ( idxs_ ): \"\"\"Select records by shuffled indices. Args: idxs_: Indices to extract from the records list. Returns: Ordered list of ``ReactionRecord`` instances corresponding to ``idxs_``. \"\"\" return [ records [ i ] for i in idxs_ ] return pick ( train_idx ), pick ( valid_idx ), pick ( test_idx ) canonicalize_reaction \u00b6 canonicalize_reaction ( record , isomeric = True ) Return a new ReactionRecord with all SMILES canonicalized. Parameters: Name Type Description Default record ReactionRecord Reaction record to convert. required isomeric bool Preserve stereochemistry in canonical SMILES when True. True Returns: Type Description ReactionRecord A new ReactionRecord containing canonicalized SMILES and copied metadata. Source code in chemrxn_cleaner/parser.py 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 def canonicalize_reaction ( record : ReactionRecord , isomeric : bool = True , ) -> ReactionRecord : \"\"\"Return a new ReactionRecord with all SMILES canonicalized. Args: record: Reaction record to convert. isomeric: Preserve stereochemistry in canonical SMILES when True. Returns: A new ReactionRecord containing canonicalized SMILES and copied metadata. \"\"\" canon_reactants = canonicalize_smiles_list ( record . reactants , isomeric = isomeric ) canon_reagents = canonicalize_smiles_list ( record . reagents , isomeric = isomeric ) canon_products = canonicalize_smiles_list ( record . products , isomeric = isomeric ) return ReactionRecord ( reaction_smiles = record . reaction_smiles , reactants = canon_reactants , reagents = canon_reagents , products = canon_products , extra_metadata = dict ( record . extra_metadata or {}), ) parse_reaction_smiles \u00b6 parse_reaction_smiles ( rxn_smiles , strict = True , strip_atom_mapping = False ) Parse a reaction SMILES string into a ReactionRecord . Reaction SMILES must follow reactants>reagents>products . When strict is False, missing fields are padded with empty strings instead of raising. Parameters: Name Type Description Default rxn_smiles str Raw reaction SMILES string to parse. required strict bool Enforce exactly three > -separated parts when True. True strip_atom_mapping bool When True, remove atom-map numbers and store the original mapped string in atom_mapping . False Returns: Type Description ReactionRecord ReactionRecord with parsed reactants, reagents, and products lists. Raises: Type Description ValueError If rxn_smiles is None or incorrectly formatted when strict is True. Source code in chemrxn_cleaner/parser.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 def parse_reaction_smiles ( rxn_smiles : str , strict : bool = True , strip_atom_mapping : bool = False , ) -> ReactionRecord : \"\"\"Parse a reaction SMILES string into a ``ReactionRecord``. Reaction SMILES must follow ``reactants>reagents>products``. When ``strict`` is False, missing fields are padded with empty strings instead of raising. Args: rxn_smiles: Raw reaction SMILES string to parse. strict: Enforce exactly three ``>``-separated parts when True. strip_atom_mapping: When True, remove atom-map numbers and store the original mapped string in ``atom_mapping``. Returns: ReactionRecord with parsed reactants, reagents, and products lists. Raises: ValueError: If ``rxn_smiles`` is None or incorrectly formatted when ``strict`` is True. \"\"\" if rxn_smiles is None : logger . error ( \"rxn_smiles cannot be None.\" ) raise ValueError ( \"rxn_smiles cannot be None.\" ) rxn_smiles = rxn_smiles . strip () atom_mapping : Optional [ str ] = None if strip_atom_mapping : rxn_smiles , atom_mapping = _strip_atom_mapping_tokens ( rxn_smiles ) parts = rxn_smiles . split ( \">\" ) if len ( parts ) != 3 : if strict : logger . error ( \"Invalid reaction SMILES format: %r \" , rxn_smiles ) raise ValueError ( f \"Invalid reaction SMILES format: { rxn_smiles !r} \" ) else : # Pad or truncate to length 3 parts = ( parts + [ \"\" , \"\" , \"\" ])[: 3 ] reactants_block , reagents_block , products_block = parts reactants = parse_smiles_list ( reactants_block ) reagents = parse_smiles_list ( reagents_block ) products = parse_smiles_list ( products_block ) return ReactionRecord ( reaction_smiles = rxn_smiles , reactants = reactants , reagents = reagents , products = products , atom_mapping = atom_mapping , ) similarity_filter \u00b6 similarity_filter ( query_smiles , role = 'any' , threshold = 0.7 , radius = 2 , n_bits = 2048 ) Return a similarity-based ReactionFilter . Parameters: Name Type Description Default query_smiles Union [ str , List [ str ]] Target structure(s) expressed as SMILES. required role Literal ['reactant', 'reagent', 'product', 'any'] Molecular role(s) to check; \"any\" inspects reactants, reagents, and products. 'any' threshold float Tanimoto similarity cutoff; scores >= threshold count as a hit. 0.7 radius int Morgan fingerprint radius (2 for ECFP4, 3 for ECFP6). 2 n_bits int Length of the fingerprint bit vector. 2048 Returns: Type Description ReactionFilter ReactionFilter predicate that keeps reactions containing at least one ReactionFilter molecule similar to the query. Raises: Type Description ValueError If any query SMILES cannot be parsed. Source code in chemrxn_cleaner/utils/similarity.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def similarity_filter ( query_smiles : Union [ str , List [ str ]], role : Literal [ \"reactant\" , \"reagent\" , \"product\" , \"any\" ] = \"any\" , threshold : float = 0.7 , radius : int = 2 , n_bits : int = 2048 , ) -> ReactionFilter : \"\"\"Return a similarity-based ``ReactionFilter``. Args: query_smiles: Target structure(s) expressed as SMILES. role: Molecular role(s) to check; ``\"any\"`` inspects reactants, reagents, and products. threshold: Tanimoto similarity cutoff; scores >= ``threshold`` count as a hit. radius: Morgan fingerprint radius (2 for ECFP4, 3 for ECFP6). n_bits: Length of the fingerprint bit vector. Returns: ReactionFilter predicate that keeps reactions containing at least one molecule similar to the query. Raises: ValueError: If any query SMILES cannot be parsed. \"\"\" cfg = FingerprintConfig ( radius = radius , n_bits = n_bits ) # Normalize into a list if isinstance ( query_smiles , str ): query_list = [ query_smiles ] else : query_list = list ( query_smiles ) # Pre-compute all query fingerprints query_fps : List [ DataStructs . ExplicitBitVect ] = [] for q in query_list : fp = _fingerprint_from_smiles ( q , cfg ) if fp is None : raise ValueError ( f \"Invalid query SMILES: { q } \" ) query_fps . append ( fp ) def _filter ( rxn : ReactionRecord ) -> bool : \"\"\"Return True when any molecule exceeds the similarity threshold. Args: rxn: Reaction to compare against the query fingerprints. Returns: True when at least one molecule meets or exceeds ``threshold``. \"\"\" # Adjust here if you need every query matched instead of any for smi in _iter_molecule_smiles ( rxn , role ): fp = _fingerprint_from_smiles ( smi , cfg ) if fp is None : continue # Compare with all queries; any sufficiently similar molecule counts for qfp in query_fps : sim = DataStructs . TanimotoSimilarity ( fp , qfp ) if sim >= threshold : return True return False _filter . __name__ = \"similarity_filter\" return _filter","title":"API Reference"},{"location":"api/#api-reference","text":"","title":"API reference"},{"location":"api/#chemrxn_cleaner","text":"","title":"chemrxn_cleaner"},{"location":"api/#chemrxn_cleaner.ElementFilterRule","text":"Allowed or forbidden element symbols by reaction role. Attributes: Name Type Description reactantElements List [ str ] Allowed/forbidden element symbols for reactants. reagentElements List [ str ] Allowed/forbidden element symbols for reagents. productElements List [ str ] Allowed/forbidden element symbols for products. Source code in chemrxn_cleaner/filters.py 13 14 15 16 17 18 19 20 21 22 23 24 25 @dataclass class ElementFilterRule : \"\"\"Allowed or forbidden element symbols by reaction role. Attributes: reactantElements: Allowed/forbidden element symbols for reactants. reagentElements: Allowed/forbidden element symbols for reagents. productElements: Allowed/forbidden element symbols for products. \"\"\" reactantElements : List [ str ] reagentElements : List [ str ] productElements : List [ str ]","title":"ElementFilterRule"},{"location":"api/#chemrxn_cleaner.ForwardReactionDataset","text":"Bases: Dataset Minimal forward-prediction dataset built on top of ReactionRecord. Source code in chemrxn_cleaner/ml/dataset.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 class ForwardReactionDataset ( Dataset ): \"\"\"Minimal forward-prediction dataset built on top of ReactionRecord.\"\"\" def __init__ ( self , records : List [ ReactionRecord ], use_agents : bool = True , ): \"\"\"Initialize the dataset. Args: records: Reaction records providing inputs and targets. use_agents: When True, include reagents/agents on the input side. \"\"\" self . records = records self . use_agents = use_agents def __len__ ( self ) -> int : \"\"\"Return the number of reactions in the dataset.\"\"\" return len ( self . records ) def _make_input_smiles ( self , r : ReactionRecord ) -> str : \"\"\"Assemble the left-hand-side SMILES string for a record. Args: r: Reaction record providing input SMILES pieces. Returns: Dot-joined SMILES string for model input. \"\"\" # left side = reactants [+ (reagents/solvents/agents)] left_parts = list ( r . reactant_smiles ) if self . use_agents : left_parts += r . reagent_smiles return \".\" . join ( left_parts ) def __getitem__ ( self , idx : int ) -> Dict [ str , Any ]: \"\"\"Return model-ready input/target pair and metadata for an index. Args: idx: Integer index into the records list. Returns: Dictionary containing ``input_smiles``, ``target_smiles``, and metadata useful for downstream models. \"\"\" r = self . records [ idx ] x = self . _make_input_smiles ( r ) y = \".\" . join ( r . product_smiles ) return { \"input_smiles\" : x , \"target_smiles\" : y , \"reaction_id\" : r . reaction_id , \"meta\" : { \"temperature_c\" : r . temperature_c , \"time_hours\" : r . time_hours , \"solvents\" : r . solvents , \"catalysts\" : r . catalysts , \"bases\" : r . bases , \"additives\" : r . additives , \"source\" : r . source , }, }","title":"ForwardReactionDataset"},{"location":"api/#chemrxn_cleaner.ForwardReactionDataset._make_input_smiles","text":"_make_input_smiles ( r ) Assemble the left-hand-side SMILES string for a record. Parameters: Name Type Description Default r ReactionRecord Reaction record providing input SMILES pieces. required Returns: Type Description str Dot-joined SMILES string for model input. Source code in chemrxn_cleaner/ml/dataset.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def _make_input_smiles ( self , r : ReactionRecord ) -> str : \"\"\"Assemble the left-hand-side SMILES string for a record. Args: r: Reaction record providing input SMILES pieces. Returns: Dot-joined SMILES string for model input. \"\"\" # left side = reactants [+ (reagents/solvents/agents)] left_parts = list ( r . reactant_smiles ) if self . use_agents : left_parts += r . reagent_smiles return \".\" . join ( left_parts )","title":"_make_input_smiles"},{"location":"api/#chemrxn_cleaner.CleaningStats","text":"Aggregate statistics for the overall cleaning process. Attributes: Name Type Description n_input int Total number of reactions processed. n_output int Total number of reactions kept after filtering. n_failed_parse int Number of reactions that failed SMILES parsing. per_filter Dict [ str , FilterStats ] Mapping of filter name to per-filter counters. Source code in chemrxn_cleaner/reporter.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 @dataclass class CleaningStats : \"\"\"Aggregate statistics for the overall cleaning process. Attributes: n_input: Total number of reactions processed. n_output: Total number of reactions kept after filtering. n_failed_parse: Number of reactions that failed SMILES parsing. per_filter: Mapping of filter name to per-filter counters. \"\"\" n_input : int = 0 n_output : int = 0 n_failed_parse : int = 0 per_filter : Dict [ str , FilterStats ] = field ( default_factory = dict ) def _merge_filter_stats ( self , source : Dict [ str , FilterStats ]) -> None : \"\"\"Accumulate filter-level counters from another mapping. Args: source: Mapping of filter names to stats to merge into this object. \"\"\" for name , fstats in source . items (): merged = self . per_filter . setdefault ( name , FilterStats ( name = name )) merged . applied += fstats . applied merged . passed += fstats . passed merged . failed += fstats . failed def __iadd__ ( self , other : \"CleaningStats\" ) -> \"CleaningStats\" : \"\"\"In-place addition of counters from another ``CleaningStats``. Args: other: Cleaning statistics to combine into this instance. Returns: This instance after accumulation. \"\"\" if not isinstance ( other , CleaningStats ): return NotImplemented self . n_input += other . n_input self . n_output += other . n_output self . n_failed_parse += other . n_failed_parse self . _merge_filter_stats ( other . per_filter ) return self def __add__ ( self , other : \"CleaningStats\" ) -> \"CleaningStats\" : \"\"\"Return a new ``CleaningStats`` combining two instances. Args: other: Cleaning statistics to add to this instance. Returns: A new ``CleaningStats`` containing summed counters. \"\"\" if not isinstance ( other , CleaningStats ): return NotImplemented combined = CleaningStats ( n_input = self . n_input , n_output = self . n_output , n_failed_parse = self . n_failed_parse , ) combined . _merge_filter_stats ( self . per_filter ) combined += other return combined @classmethod def combine ( cls , stats_list : Iterable [ \"CleaningStats\" ]) -> \"CleaningStats\" : \"\"\"Combine multiple ``CleaningStats`` objects (e.g., from parallel runs). Args: stats_list: Iterable of statistics objects to aggregate. Returns: Aggregate statistics across all provided objects. \"\"\" combined = cls () for stats in stats_list : combined += stats return combined def summary ( self , include_filters : bool = True ) -> str : \"\"\"Return a formatted string summarizing counters. Args: include_filters: Whether to include per-filter breakdowns. Returns: Multiline string representation of the aggregated counters. \"\"\" lines = [ f \"Input: { self . n_input } , output: { self . n_output } , \" f \"failed_parse: { self . n_failed_parse } \" ] if include_filters and self . per_filter : lines . append ( \"Per-filter:\" ) for name in sorted ( self . per_filter . keys ()): lines . append ( f \" { self . per_filter [ name ] } \" ) return \" \\n \" . join ( lines ) def __str__ ( self ) -> str : return self . summary ()","title":"CleaningStats"},{"location":"api/#chemrxn_cleaner.CleaningStats._merge_filter_stats","text":"_merge_filter_stats ( source ) Accumulate filter-level counters from another mapping. Parameters: Name Type Description Default source Dict [ str , FilterStats ] Mapping of filter names to stats to merge into this object. required Source code in chemrxn_cleaner/reporter.py 52 53 54 55 56 57 58 59 60 61 62 def _merge_filter_stats ( self , source : Dict [ str , FilterStats ]) -> None : \"\"\"Accumulate filter-level counters from another mapping. Args: source: Mapping of filter names to stats to merge into this object. \"\"\" for name , fstats in source . items (): merged = self . per_filter . setdefault ( name , FilterStats ( name = name )) merged . applied += fstats . applied merged . passed += fstats . passed merged . failed += fstats . failed","title":"_merge_filter_stats"},{"location":"api/#chemrxn_cleaner.CleaningStats.combine","text":"combine ( stats_list ) Combine multiple CleaningStats objects (e.g., from parallel runs). Parameters: Name Type Description Default stats_list Iterable ['CleaningStats'] Iterable of statistics objects to aggregate. required Returns: Type Description 'CleaningStats' Aggregate statistics across all provided objects. Source code in chemrxn_cleaner/reporter.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 @classmethod def combine ( cls , stats_list : Iterable [ \"CleaningStats\" ]) -> \"CleaningStats\" : \"\"\"Combine multiple ``CleaningStats`` objects (e.g., from parallel runs). Args: stats_list: Iterable of statistics objects to aggregate. Returns: Aggregate statistics across all provided objects. \"\"\" combined = cls () for stats in stats_list : combined += stats return combined","title":"combine"},{"location":"api/#chemrxn_cleaner.CleaningStats.summary","text":"summary ( include_filters = True ) Return a formatted string summarizing counters. Parameters: Name Type Description Default include_filters bool Whether to include per-filter breakdowns. True Returns: Type Description str Multiline string representation of the aggregated counters. Source code in chemrxn_cleaner/reporter.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def summary ( self , include_filters : bool = True ) -> str : \"\"\"Return a formatted string summarizing counters. Args: include_filters: Whether to include per-filter breakdowns. Returns: Multiline string representation of the aggregated counters. \"\"\" lines = [ f \"Input: { self . n_input } , output: { self . n_output } , \" f \"failed_parse: { self . n_failed_parse } \" ] if include_filters and self . per_filter : lines . append ( \"Per-filter:\" ) for name in sorted ( self . per_filter . keys ()): lines . append ( f \" { self . per_filter [ name ] } \" ) return \" \\n \" . join ( lines )","title":"summary"},{"location":"api/#chemrxn_cleaner.FilterStats","text":"Accumulates counts for an individual reaction filter. Attributes: Name Type Description name str Human-readable filter identifier. applied int Number of times the filter was evaluated. passed int Number of reactions accepted by the filter. failed int Number of reactions rejected by the filter. Source code in chemrxn_cleaner/reporter.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @dataclass class FilterStats : \"\"\"Accumulates counts for an individual reaction filter. Attributes: name: Human-readable filter identifier. applied: Number of times the filter was evaluated. passed: Number of reactions accepted by the filter. failed: Number of reactions rejected by the filter. \"\"\" name : str applied : int = 0 passed : int = 0 failed : int = 0 def format ( self ) -> str : \"\"\"Return a concise one-line summary of the counts.\"\"\" return ( f \" { self . name } : applied= { self . applied } , \" f \"passed= { self . passed } , failed= { self . failed } \" ) def __str__ ( self ) -> str : return self . format ()","title":"FilterStats"},{"location":"api/#chemrxn_cleaner.FilterStats.format","text":"format () Return a concise one-line summary of the counts. Source code in chemrxn_cleaner/reporter.py 25 26 27 28 29 30 def format ( self ) -> str : \"\"\"Return a concise one-line summary of the counts.\"\"\" return ( f \" { self . name } : applied= { self . applied } , \" f \"passed= { self . passed } , failed= { self . failed } \" )","title":"format"},{"location":"api/#chemrxn_cleaner.ReactionRecord","text":"Container for a single reaction instance. Attributes: Name Type Description reaction_id str Unique identifier for the reaction within a dataset. source str Origin of the reaction data (e.g., \"uspto\" , \"ord\" ). source_ref Optional [ str ] Reference such as DOI or patent number. source_file_path Optional [ str ] File path from which the record was loaded. reaction_smiles str Raw reaction SMILES string. reactants List [ str ] Reactant SMILES strings. reagents List [ str ] Reagent/agent SMILES strings. products List [ str ] Product SMILES strings. atom_mapping Optional [ str ] Optional atom-mapped reaction SMILES. reaction_class Optional [ str ] Optional reaction class label. procedure Dict [ str , Any ] Experimental procedure or flattened metadata. temperature_c Optional [ float ] Reaction temperature in Celsius. time_hours Optional [ float ] Reaction time in hours. pressure_bar Optional [ float ] Reaction pressure in bar. ph Optional [ float ] Observed or targeted pH. solvents List [ str ] List of solvent identifiers. catalysts List [ str ] List of catalysts. bases List [ str ] List of bases. additives List [ str ] List of other additives. atmosphere Optional [ str ] Reaction atmosphere description. scale_mmol Optional [ float ] Reaction scale in millimoles. yield_value Optional [ float ] Reported yield numeric value. yield_type YieldType Category describing how yield_value was measured. success Optional [ bool ] Optional boolean flag for reaction success. selectivity Optional [ float ] Selectivity metric value, if provided. selectivity_type Optional [ str ] Descriptor for the selectivity metric. is_balanced Optional [ bool ] Whether the reaction is atom-balanced. sanity_check_passed bool Indicates whether sanity checks passed. warnings List [ str ] Free-form warnings accumulated during processing. split Optional [ str ] Dataset split label (e.g., train/valid/test). extra_numeric Dict [ str , float ] Additional numeric metadata keyed by name. extra_categorical Dict [ str , str ] Additional categorical metadata keyed by name. extra_metadata Dict [ str , Any ] Unstructured metadata not captured elsewhere. Source code in chemrxn_cleaner/types.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 @dataclass class ReactionRecord : \"\"\"Container for a single reaction instance. Attributes: reaction_id: Unique identifier for the reaction within a dataset. source: Origin of the reaction data (e.g., ``\"uspto\"``, ``\"ord\"``). source_ref: Reference such as DOI or patent number. source_file_path: File path from which the record was loaded. reaction_smiles: Raw reaction SMILES string. reactants: Reactant SMILES strings. reagents: Reagent/agent SMILES strings. products: Product SMILES strings. atom_mapping: Optional atom-mapped reaction SMILES. reaction_class: Optional reaction class label. procedure: Experimental procedure or flattened metadata. temperature_c: Reaction temperature in Celsius. time_hours: Reaction time in hours. pressure_bar: Reaction pressure in bar. ph: Observed or targeted pH. solvents: List of solvent identifiers. catalysts: List of catalysts. bases: List of bases. additives: List of other additives. atmosphere: Reaction atmosphere description. scale_mmol: Reaction scale in millimoles. yield_value: Reported yield numeric value. yield_type: Category describing how ``yield_value`` was measured. success: Optional boolean flag for reaction success. selectivity: Selectivity metric value, if provided. selectivity_type: Descriptor for the selectivity metric. is_balanced: Whether the reaction is atom-balanced. sanity_check_passed: Indicates whether sanity checks passed. warnings: Free-form warnings accumulated during processing. split: Dataset split label (e.g., train/valid/test). extra_numeric: Additional numeric metadata keyed by name. extra_categorical: Additional categorical metadata keyed by name. extra_metadata: Unstructured metadata not captured elsewhere. \"\"\" # ---- Required identifiers / core representation ---- reaction_id : str = \"\" source : str = \"\" source_ref : Optional [ str ] = None source_file_path : Optional [ str ] = None reaction_smiles : str = \"\" # raw SMILES strings reactants : List [ str ] = field ( default_factory = list ) reagents : List [ str ] = field ( default_factory = list ) products : List [ str ] = field ( default_factory = list ) atom_mapping : Optional [ str ] = None reaction_class : Optional [ str ] = None # ---- Experimental conditions ---- temperature_c : Optional [ float ] = None time_hours : Optional [ float ] = None pressure_bar : Optional [ float ] = None ph : Optional [ float ] = None procedure : Dict [ str , Any ] = field ( default_factory = dict ) solvents : List [ str ] = field ( default_factory = list ) catalysts : List [ str ] = field ( default_factory = list ) bases : List [ str ] = field ( default_factory = list ) additives : List [ str ] = field ( default_factory = list ) atmosphere : Optional [ str ] = None scale_mmol : Optional [ float ] = None # ---- Outcomes (targets / labels) ---- yield_value : Optional [ float ] = None yield_type : YieldType = YieldType . NONE success : Optional [ bool ] = None # ---- selectivity ---- selectivity : Optional [ float ] = None selectivity_type : Optional [ str ] = None # ---- Data-quality / bookkeeping ---- is_balanced : Optional [ bool ] = None sanity_check_passed : bool = True warnings : List [ str ] = field ( default_factory = list ) # Dataset management only \u2013 e.g. \u201ctrain/valid/test/time_split\u201d split : Optional [ str ] = None # ---- Extension hooks ---- extra_numeric : Dict [ str , float ] = field ( default_factory = dict ) extra_categorical : Dict [ str , str ] = field ( default_factory = dict ) extra_metadata : Dict [ str , Any ] = field ( default_factory = dict ) def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Return a plain-Python representation that is JSON serializable. Returns: Dictionary containing shallow copies of all fields suitable for JSON serialization. \"\"\" return { \"reaction_id\" : self . reaction_id , \"source\" : self . source , \"source_ref\" : self . source_ref , \"source_file_path\" : self . source_file_path , \"reaction_smiles\" : self . reaction_smiles , \"reactants\" : list ( self . reactants ), \"reagents\" : list ( self . reagents ), \"products\" : list ( self . products ), \"atom_mapping\" : self . atom_mapping , \"reaction_class\" : self . reaction_class , \"procedure\" : dict ( self . procedure ), \"temperature_c\" : self . temperature_c , \"time_hours\" : self . time_hours , \"pressure_bar\" : self . pressure_bar , \"ph\" : self . ph , \"solvents\" : list ( self . solvents ), \"catalysts\" : list ( self . catalysts ), \"bases\" : list ( self . bases ), \"additives\" : list ( self . additives ), \"atmosphere\" : self . atmosphere , \"scale_mmol\" : self . scale_mmol , \"yield_value\" : self . yield_value , \"yield_type\" : self . yield_type . value if self . yield_type else None , \"success\" : self . success , \"selectivity\" : self . selectivity , \"selectivity_type\" : self . selectivity_type , \"is_balanced\" : self . is_balanced , \"sanity_check_passed\" : self . sanity_check_passed , \"warnings\" : list ( self . warnings ), \"split\" : self . split , \"extra_numeric\" : dict ( self . extra_numeric ), \"extra_categorical\" : dict ( self . extra_categorical ), \"extra_metadata\" : dict ( self . extra_metadata or {}), } @classmethod def from_dict ( cls , data : Dict [ str , Any ]) -> \"ReactionRecord\" : \"\"\"Construct a ``ReactionRecord`` from a dictionary payload. Args: data: Mapping produced by ``to_dict`` or a similarly structured dictionary. Returns: A populated ``ReactionRecord`` instance. \"\"\" yield_type_value = data . get ( \"yield_type\" ) or YieldType . NONE if isinstance ( yield_type_value , str ): try : yield_type_enum = YieldType ( yield_type_value ) except ValueError : yield_type_enum = YieldType . NONE else : yield_type_enum = yield_type_value return cls ( reaction_id = data . get ( \"reaction_id\" , \"\" ), source = data . get ( \"source\" , \"\" ), source_ref = data . get ( \"source_ref\" ), source_file_path = data . get ( \"source_file_path\" ), reaction_smiles = data . get ( \"reaction_smiles\" ) or data . get ( \"raw\" , \"\" ), reactants = list ( data . get ( \"reactants\" , []) or []), reagents = list ( data . get ( \"reagents\" , []) or []), products = list ( data . get ( \"products\" , []) or []), atom_mapping = data . get ( \"atom_mapping\" ), reaction_class = data . get ( \"reaction_class\" ), procedure = dict ( data . get ( \"procedure\" , {}) or {}), temperature_c = data . get ( \"temperature_c\" ), time_hours = data . get ( \"time_hours\" ), pressure_bar = data . get ( \"pressure_bar\" ), ph = data . get ( \"ph\" ), solvents = list ( data . get ( \"solvents\" , []) or []), catalysts = list ( data . get ( \"catalysts\" , []) or []), bases = list ( data . get ( \"bases\" , []) or []), additives = list ( data . get ( \"additives\" , []) or []), atmosphere = data . get ( \"atmosphere\" ), scale_mmol = data . get ( \"scale_mmol\" ), yield_value = data . get ( \"yield_value\" ), yield_type = yield_type_enum , success = data . get ( \"success\" ), selectivity = data . get ( \"selectivity\" ), selectivity_type = data . get ( \"selectivity_type\" ), is_balanced = data . get ( \"is_balanced\" ), sanity_check_passed = data . get ( \"sanity_check_passed\" , True ), warnings = list ( data . get ( \"warnings\" , []) or []), split = data . get ( \"split\" ), extra_numeric = dict ( data . get ( \"extra_numeric\" , {}) or {}), extra_categorical = dict ( data . get ( \"extra_categorical\" , {}) or {}), extra_metadata = cls . _merge_extra_metadata ( data ), ) @classmethod def _merge_extra_metadata ( cls , data : Dict [ str , Any ]) -> Dict [ str , Any ]: \"\"\"Combine explicit extra metadata with any unknown top-level keys.\"\"\" base_meta = data . get ( \"extra_metadata\" ) or {} if isinstance ( base_meta , dict ): extra_meta = dict ( base_meta ) else : try : extra_meta = dict ( base_meta ) except Exception : extra_meta = {} meta_alias = data . get ( \"meta\" ) if isinstance ( meta_alias , dict ): extra_meta . update ( meta_alias ) known_keys = set ( cls . __dataclass_fields__ . keys ()) | { \"meta\" } for key , value in data . items (): if key not in known_keys and key not in extra_meta : extra_meta [ key ] = value return extra_meta def __post_init__ ( self ) -> None : \"\"\"Ensure optional mapping fields default to empty dictionaries.\"\"\" if self . extra_metadata is None : self . extra_metadata = {} if self . procedure is None : self . procedure = {} def show ( self , size : tuple [ int , int ] = ( 2400 , 600 ), jupyter : bool = True , with_meta : bool = True , show_atom_map_numbers : bool = False , ): \"\"\"Visualize the reaction using RDKit. Args: size: Tuple of pixel dimensions for the rendered image. jupyter: When True, display inline using IPython display hooks. with_meta: When True, show ``extra_metadata`` alongside the image. show_atom_map_numbers: When True, keep atom-map numbers in the depiction; when False, they are stripped before drawing. \"\"\" from rdkit.Chem import Draw , rdChemReactions rxn_smiles = self . reaction_smiles rxn = rdChemReactions . ReactionFromSmarts ( rxn_smiles , useSmiles = True ) if not show_atom_map_numbers : # Remove atom-map numbers to avoid numbered atom labels in depictions. for mol in ( list ( rxn . GetReactants ()) + list ( rxn . GetProducts ()) + list ( rxn . GetAgents ()) ): for atom in mol . GetAtoms (): if atom . HasProp ( \"molAtomMapNumber\" ): atom . ClearProp ( \"molAtomMapNumber\" ) img = Draw . ReactionToImage ( rxn , subImgSize = ( size [ 0 ] // 3 , size [ 1 ])) if jupyter : try : from IPython.display import HTML , display except ImportError : # pragma: no cover - optional dependency jupyter = False else : display ( img ) if with_meta and self . extra_metadata : rows = \"\" . join ( f \"<tr><th> { k } </th><td> { v } </td></tr>\" for k , v in self . extra_metadata . items () ) display ( HTML ( \"<table border='1' style='border-collapse:collapse;'>\" f \" { rows } </table>\" ) ) if not jupyter : try : img . show () except Exception as exc : # pragma: no cover - environment specific print ( \"Unable to open the image viewer.\" \" Consider running in a Jupyter environment.\" ) print ( f \"Original error: { exc } \" ) if with_meta and self . extra_metadata : print ( \"Metadata:\" ) for k , v in self . extra_metadata . items (): print ( f \" { k } : { v } \" ) return img","title":"ReactionRecord"},{"location":"api/#chemrxn_cleaner.ReactionRecord.to_dict","text":"to_dict () Return a plain-Python representation that is JSON serializable. Returns: Type Description Dict [ str , Any ] Dictionary containing shallow copies of all fields suitable for JSON Dict [ str , Any ] serialization. Source code in chemrxn_cleaner/types.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Return a plain-Python representation that is JSON serializable. Returns: Dictionary containing shallow copies of all fields suitable for JSON serialization. \"\"\" return { \"reaction_id\" : self . reaction_id , \"source\" : self . source , \"source_ref\" : self . source_ref , \"source_file_path\" : self . source_file_path , \"reaction_smiles\" : self . reaction_smiles , \"reactants\" : list ( self . reactants ), \"reagents\" : list ( self . reagents ), \"products\" : list ( self . products ), \"atom_mapping\" : self . atom_mapping , \"reaction_class\" : self . reaction_class , \"procedure\" : dict ( self . procedure ), \"temperature_c\" : self . temperature_c , \"time_hours\" : self . time_hours , \"pressure_bar\" : self . pressure_bar , \"ph\" : self . ph , \"solvents\" : list ( self . solvents ), \"catalysts\" : list ( self . catalysts ), \"bases\" : list ( self . bases ), \"additives\" : list ( self . additives ), \"atmosphere\" : self . atmosphere , \"scale_mmol\" : self . scale_mmol , \"yield_value\" : self . yield_value , \"yield_type\" : self . yield_type . value if self . yield_type else None , \"success\" : self . success , \"selectivity\" : self . selectivity , \"selectivity_type\" : self . selectivity_type , \"is_balanced\" : self . is_balanced , \"sanity_check_passed\" : self . sanity_check_passed , \"warnings\" : list ( self . warnings ), \"split\" : self . split , \"extra_numeric\" : dict ( self . extra_numeric ), \"extra_categorical\" : dict ( self . extra_categorical ), \"extra_metadata\" : dict ( self . extra_metadata or {}), }","title":"to_dict"},{"location":"api/#chemrxn_cleaner.ReactionRecord.from_dict","text":"from_dict ( data ) Construct a ReactionRecord from a dictionary payload. Parameters: Name Type Description Default data Dict [ str , Any ] Mapping produced by to_dict or a similarly structured dictionary. required Returns: Type Description ReactionRecord A populated ReactionRecord instance. Source code in chemrxn_cleaner/types.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 @classmethod def from_dict ( cls , data : Dict [ str , Any ]) -> \"ReactionRecord\" : \"\"\"Construct a ``ReactionRecord`` from a dictionary payload. Args: data: Mapping produced by ``to_dict`` or a similarly structured dictionary. Returns: A populated ``ReactionRecord`` instance. \"\"\" yield_type_value = data . get ( \"yield_type\" ) or YieldType . NONE if isinstance ( yield_type_value , str ): try : yield_type_enum = YieldType ( yield_type_value ) except ValueError : yield_type_enum = YieldType . NONE else : yield_type_enum = yield_type_value return cls ( reaction_id = data . get ( \"reaction_id\" , \"\" ), source = data . get ( \"source\" , \"\" ), source_ref = data . get ( \"source_ref\" ), source_file_path = data . get ( \"source_file_path\" ), reaction_smiles = data . get ( \"reaction_smiles\" ) or data . get ( \"raw\" , \"\" ), reactants = list ( data . get ( \"reactants\" , []) or []), reagents = list ( data . get ( \"reagents\" , []) or []), products = list ( data . get ( \"products\" , []) or []), atom_mapping = data . get ( \"atom_mapping\" ), reaction_class = data . get ( \"reaction_class\" ), procedure = dict ( data . get ( \"procedure\" , {}) or {}), temperature_c = data . get ( \"temperature_c\" ), time_hours = data . get ( \"time_hours\" ), pressure_bar = data . get ( \"pressure_bar\" ), ph = data . get ( \"ph\" ), solvents = list ( data . get ( \"solvents\" , []) or []), catalysts = list ( data . get ( \"catalysts\" , []) or []), bases = list ( data . get ( \"bases\" , []) or []), additives = list ( data . get ( \"additives\" , []) or []), atmosphere = data . get ( \"atmosphere\" ), scale_mmol = data . get ( \"scale_mmol\" ), yield_value = data . get ( \"yield_value\" ), yield_type = yield_type_enum , success = data . get ( \"success\" ), selectivity = data . get ( \"selectivity\" ), selectivity_type = data . get ( \"selectivity_type\" ), is_balanced = data . get ( \"is_balanced\" ), sanity_check_passed = data . get ( \"sanity_check_passed\" , True ), warnings = list ( data . get ( \"warnings\" , []) or []), split = data . get ( \"split\" ), extra_numeric = dict ( data . get ( \"extra_numeric\" , {}) or {}), extra_categorical = dict ( data . get ( \"extra_categorical\" , {}) or {}), extra_metadata = cls . _merge_extra_metadata ( data ), )","title":"from_dict"},{"location":"api/#chemrxn_cleaner.ReactionRecord._merge_extra_metadata","text":"_merge_extra_metadata ( data ) Combine explicit extra metadata with any unknown top-level keys. Source code in chemrxn_cleaner/types.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 @classmethod def _merge_extra_metadata ( cls , data : Dict [ str , Any ]) -> Dict [ str , Any ]: \"\"\"Combine explicit extra metadata with any unknown top-level keys.\"\"\" base_meta = data . get ( \"extra_metadata\" ) or {} if isinstance ( base_meta , dict ): extra_meta = dict ( base_meta ) else : try : extra_meta = dict ( base_meta ) except Exception : extra_meta = {} meta_alias = data . get ( \"meta\" ) if isinstance ( meta_alias , dict ): extra_meta . update ( meta_alias ) known_keys = set ( cls . __dataclass_fields__ . keys ()) | { \"meta\" } for key , value in data . items (): if key not in known_keys and key not in extra_meta : extra_meta [ key ] = value return extra_meta","title":"_merge_extra_metadata"},{"location":"api/#chemrxn_cleaner.ReactionRecord.show","text":"show ( size = ( 2400 , 600 ), jupyter = True , with_meta = True , show_atom_map_numbers = False ) Visualize the reaction using RDKit. Parameters: Name Type Description Default size tuple [ int , int ] Tuple of pixel dimensions for the rendered image. (2400, 600) jupyter bool When True, display inline using IPython display hooks. True with_meta bool When True, show extra_metadata alongside the image. True show_atom_map_numbers bool When True, keep atom-map numbers in the depiction; when False, they are stripped before drawing. False Source code in chemrxn_cleaner/types.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 def show ( self , size : tuple [ int , int ] = ( 2400 , 600 ), jupyter : bool = True , with_meta : bool = True , show_atom_map_numbers : bool = False , ): \"\"\"Visualize the reaction using RDKit. Args: size: Tuple of pixel dimensions for the rendered image. jupyter: When True, display inline using IPython display hooks. with_meta: When True, show ``extra_metadata`` alongside the image. show_atom_map_numbers: When True, keep atom-map numbers in the depiction; when False, they are stripped before drawing. \"\"\" from rdkit.Chem import Draw , rdChemReactions rxn_smiles = self . reaction_smiles rxn = rdChemReactions . ReactionFromSmarts ( rxn_smiles , useSmiles = True ) if not show_atom_map_numbers : # Remove atom-map numbers to avoid numbered atom labels in depictions. for mol in ( list ( rxn . GetReactants ()) + list ( rxn . GetProducts ()) + list ( rxn . GetAgents ()) ): for atom in mol . GetAtoms (): if atom . HasProp ( \"molAtomMapNumber\" ): atom . ClearProp ( \"molAtomMapNumber\" ) img = Draw . ReactionToImage ( rxn , subImgSize = ( size [ 0 ] // 3 , size [ 1 ])) if jupyter : try : from IPython.display import HTML , display except ImportError : # pragma: no cover - optional dependency jupyter = False else : display ( img ) if with_meta and self . extra_metadata : rows = \"\" . join ( f \"<tr><th> { k } </th><td> { v } </td></tr>\" for k , v in self . extra_metadata . items () ) display ( HTML ( \"<table border='1' style='border-collapse:collapse;'>\" f \" { rows } </table>\" ) ) if not jupyter : try : img . show () except Exception as exc : # pragma: no cover - environment specific print ( \"Unable to open the image viewer.\" \" Consider running in a Jupyter environment.\" ) print ( f \"Original error: { exc } \" ) if with_meta and self . extra_metadata : print ( \"Metadata:\" ) for k , v in self . extra_metadata . items (): print ( f \" { k } : { v } \" ) return img","title":"show"},{"location":"api/#chemrxn_cleaner.clean_and_canonicalize","text":"clean_and_canonicalize ( rxn_smiles_list , filters = None , drop_failed_parse = True , strict = True , isomeric = True ) Clean reactions and canonicalize all SMILES in one pass. Parameters: Name Type Description Default rxn_smiles_list Iterable [ ReactionRecord ] Iterable of ReactionRecords to clean. required filters Optional [ List [ ReactionFilter ]] Optional list of filter predicates; falls back to default_filters() when None. None drop_failed_parse bool Whether to drop reactions that fail parsing rather than raising. True strict bool Enforce exactly three > parts in reaction SMILES when True. True isomeric bool Preserve isomeric information during canonicalization. True Returns: Type Description List [ ReactionRecord ] Reaction records with canonicalized reactants, reagents, and products. Source code in chemrxn_cleaner/cleaner.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 def clean_and_canonicalize ( rxn_smiles_list : Iterable [ ReactionRecord ], filters : Optional [ List [ ReactionFilter ]] = None , drop_failed_parse : bool = True , strict : bool = True , isomeric : bool = True , ) -> List [ ReactionRecord ]: \"\"\"Clean reactions and canonicalize all SMILES in one pass. Args: rxn_smiles_list: Iterable of ReactionRecords to clean. filters: Optional list of filter predicates; falls back to ``default_filters()`` when None. drop_failed_parse: Whether to drop reactions that fail parsing rather than raising. strict: Enforce exactly three ``>`` parts in reaction SMILES when True. isomeric: Preserve isomeric information during canonicalization. Returns: Reaction records with canonicalized reactants, reagents, and products. \"\"\" cleaned = clean_reactions ( rxn_smiles_list = rxn_smiles_list , filters = filters , drop_failed_parse = drop_failed_parse , strict = strict , ) logger . info ( \"Canonicalizing %d reactions (isomeric= %s )\" , len ( cleaned ), isomeric ) canon_records : List [ ReactionRecord ] = [] for rec in cleaned : try : canon_records . append ( canonicalize_reaction ( rec , isomeric = isomeric )) except Exception : logger . exception ( \"Canonicalization failed for reaction %s \" , rec . reaction_id or rec . reaction_smiles or \"<unknown>\" , ) raise return canon_records","title":"clean_and_canonicalize"},{"location":"api/#chemrxn_cleaner.clean_reactions","text":"clean_reactions ( rxn_smiles_list , filters = None , drop_failed_parse = True , strict = True ) Parse, validate, and filter reaction records. Parameters: Name Type Description Default rxn_smiles_list Iterable [ ReactionRecord ] Iterable of reactions. Empty reactant/reagent/product fields are parsed from reaction_smiles when present. required filters Optional [ List [ ReactionFilter ]] Optional list of predicate callables; defaults to default_filters() when omitted. None drop_failed_parse bool When True, quietly drop reactions that cannot be parsed; when False, propagate the parsing error. True strict bool Passed to parse_reaction_smiles ; enforces three '>' parts when True, otherwise pads missing parts. True Returns: Type Description List [ ReactionRecord ] Cleaned reactions that passed all filters. Source code in chemrxn_cleaner/cleaner.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 def clean_reactions ( rxn_smiles_list : Iterable [ ReactionRecord ], filters : Optional [ List [ ReactionFilter ]] = None , drop_failed_parse : bool = True , strict : bool = True , ) -> List [ ReactionRecord ]: \"\"\"Parse, validate, and filter reaction records. Args: rxn_smiles_list: Iterable of reactions. Empty reactant/reagent/product fields are parsed from ``reaction_smiles`` when present. filters: Optional list of predicate callables; defaults to ``default_filters()`` when omitted. drop_failed_parse: When True, quietly drop reactions that cannot be parsed; when False, propagate the parsing error. strict: Passed to ``parse_reaction_smiles``; enforces three '>' parts when True, otherwise pads missing parts. Returns: Cleaned reactions that passed all filters. \"\"\" cleaned , _ = _clean_reactions_internal ( rxn_smiles_list = rxn_smiles_list , filters = filters , drop_failed_parse = drop_failed_parse , strict = strict , collect_stats = False , ) return cleaned","title":"clean_reactions"},{"location":"api/#chemrxn_cleaner.clean_reactions_with_report","text":"clean_reactions_with_report ( rxn_smiles_list , filters = None , drop_failed_parse = True , strict = True ) Run the cleaning pipeline and return results plus statistics. Parameters: Name Type Description Default rxn_smiles_list Iterable [ ReactionRecord ] Iterable of input reactions to process. required filters Optional [ List [ ReactionFilter ]] Optional list of filters to apply; defaults to default_filters() when omitted. None drop_failed_parse bool Whether to drop reactions that cannot be parsed instead of raising. True strict bool When True, require reaction SMILES to contain three sections. True Returns: Type Description Tuple [ List [ ReactionRecord ], CleaningStats ] A tuple of (cleaned_reactions, cleaning_stats) . Source code in chemrxn_cleaner/cleaner.py 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 def clean_reactions_with_report ( rxn_smiles_list : Iterable [ ReactionRecord ], filters : Optional [ List [ ReactionFilter ]] = None , drop_failed_parse : bool = True , strict : bool = True , ) -> Tuple [ List [ ReactionRecord ], CleaningStats ]: \"\"\"Run the cleaning pipeline and return results plus statistics. Args: rxn_smiles_list: Iterable of input reactions to process. filters: Optional list of filters to apply; defaults to ``default_filters()`` when omitted. drop_failed_parse: Whether to drop reactions that cannot be parsed instead of raising. strict: When True, require reaction SMILES to contain three sections. Returns: A tuple of ``(cleaned_reactions, cleaning_stats)``. \"\"\" return _clean_reactions_internal ( rxn_smiles_list = rxn_smiles_list , filters = filters , drop_failed_parse = drop_failed_parse , strict = strict , collect_stats = True , )","title":"clean_reactions_with_report"},{"location":"api/#chemrxn_cleaner.all_molecules_valid","text":"all_molecules_valid ( record ) Verify that all reaction molecules are valid SMILES. Parameters: Name Type Description Default record ReactionRecord Reaction to evaluate. required Returns: Type Description bool True when every reactant, reagent, and product SMILES parses in RDKit. Source code in chemrxn_cleaner/filters.py 109 110 111 112 113 114 115 116 117 118 119 120 121 def all_molecules_valid ( record : ReactionRecord ) -> bool : \"\"\"Verify that all reaction molecules are valid SMILES. Args: record: Reaction to evaluate. Returns: True when every reactant, reagent, and product SMILES parses in RDKit. \"\"\" for s in _iter_all_smiles ( record ): if not _is_valid_smiles ( s ): return False return True","title":"all_molecules_valid"},{"location":"api/#chemrxn_cleaner.default_filters","text":"default_filters () Return the default list of reaction filters. The defaults ensure at least one product is present and that all SMILES strings are valid RDKit molecules. Returns: Type Description List [ ReactionFilter ] List of basic ReactionFilter callables. Source code in chemrxn_cleaner/filters.py 275 276 277 278 279 280 281 282 283 284 285 286 287 def default_filters () -> List [ ReactionFilter ]: \"\"\"Return the default list of reaction filters. The defaults ensure at least one product is present and that all SMILES strings are valid RDKit molecules. Returns: List of basic ReactionFilter callables. \"\"\" return [ has_product , all_molecules_valid , ]","title":"default_filters"},{"location":"api/#chemrxn_cleaner.element_filter","text":"element_filter ( allowList = None , forbidList = None ) Build a ReactionFilter enforcing per-role element rules. For each reactant, reagent, and product molecule, the generated filter: 1) parses the SMILES with RDKit, 2) checks membership in allowList when provided, and 3) rejects any atom that appears in forbidList . Constraints are evaluated per role; missing rules skip that check. Parameters: Name Type Description Default allowList ElementFilterRule | None Allowed element symbols for each role. None disables allow-list filtering. None forbidList ElementFilterRule | None Forbidden element symbols for each role. None disables forbid-list filtering. None Returns: Type Description ReactionFilter ReactionFilter predicate implementing the configured constraints. Raises: Type Description ValueError If element symbols are empty or invalid. Source code in chemrxn_cleaner/filters.py 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def element_filter ( allowList : ElementFilterRule | None = None , forbidList : ElementFilterRule | None = None , ) -> ReactionFilter : \"\"\"Build a ReactionFilter enforcing per-role element rules. For each reactant, reagent, and product molecule, the generated filter: 1) parses the SMILES with RDKit, 2) checks membership in ``allowList`` when provided, and 3) rejects any atom that appears in ``forbidList``. Constraints are evaluated per role; missing rules skip that check. Args: allowList: Allowed element symbols for each role. ``None`` disables allow-list filtering. forbidList: Forbidden element symbols for each role. ``None`` disables forbid-list filtering. Returns: ReactionFilter predicate implementing the configured constraints. Raises: ValueError: If element symbols are empty or invalid. \"\"\" allowed_reactants = _normalize_element_list ( allowList . reactantElements if allowList else None ) allowed_reagents = _normalize_element_list ( allowList . reagentElements if allowList else None ) allowed_products = _normalize_element_list ( allowList . productElements if allowList else None ) forbidden_reactants = _normalize_element_list ( forbidList . reactantElements if forbidList else None ) forbidden_reagents = _normalize_element_list ( forbidList . reagentElements if forbidList else None ) forbidden_products = _normalize_element_list ( forbidList . productElements if forbidList else None ) def _check_molecules ( smiles_list : Iterable [ str ], allowed : Set [ str ] | None , forbidden : Set [ str ] | None , ) -> bool : \"\"\"Validate molecules against allowed/forbidden element sets. Args: smiles_list: SMILES strings to validate. allowed: Elements permitted for the given role, or ``None`` to skip. forbidden: Elements to reject for the given role, or ``None`` to skip. Returns: True if all molecules satisfy both element constraints. \"\"\" for smile in smiles_list : mol = Chem . MolFromSmiles ( smile ) if mol is None : return False for atom in mol . GetAtoms (): symbol = atom . GetSymbol () if allowed is not None and symbol not in allowed : return False if forbidden is not None and symbol in forbidden : return False return True def _filter ( record : ReactionRecord ) -> bool : return ( _check_molecules ( record . reactants , allowed_reactants , forbidden_reactants ) and _check_molecules ( record . reagents , allowed_reagents , forbidden_reagents ) and _check_molecules ( record . products , allowed_products , forbidden_products ) ) _filter . __name__ = \"element_filter\" return _filter","title":"element_filter"},{"location":"api/#chemrxn_cleaner.has_product","text":"has_product ( record ) Check whether the reaction contains at least one product molecule. Parameters: Name Type Description Default record ReactionRecord Reaction to evaluate. required Returns: Type Description bool True when at least one product SMILES is present. Source code in chemrxn_cleaner/filters.py 97 98 99 100 101 102 103 104 105 106 def has_product ( record : ReactionRecord ) -> bool : \"\"\"Check whether the reaction contains at least one product molecule. Args: record: Reaction to evaluate. Returns: True when at least one product SMILES is present. \"\"\" return len ( record . products ) > 0","title":"has_product"},{"location":"api/#chemrxn_cleaner.max_smiles_length","text":"max_smiles_length ( max_len ) Build a filter that enforces a maximum SMILES length. Parameters: Name Type Description Default max_len int Maximum allowed character length for any SMILES string. required Returns: Type Description ReactionFilter ReactionFilter predicate that rejects reactions containing longer SMILES. Source code in chemrxn_cleaner/filters.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def max_smiles_length ( max_len : int ) -> ReactionFilter : \"\"\"Build a filter that enforces a maximum SMILES length. Args: max_len: Maximum allowed character length for any SMILES string. Returns: ReactionFilter predicate that rejects reactions containing longer SMILES. \"\"\" def _filter ( record : ReactionRecord ) -> bool : \"\"\"Return True when all SMILES strings are within the length limit. Args: record: Reaction to evaluate. Returns: True if every SMILES length is less than or equal to ``max_len``. \"\"\" for s in _iter_all_smiles ( record ): if len ( s ) > max_len : return False return True _filter . __name__ = f \"max_smiles_length( { max_len } )\" return _filter","title":"max_smiles_length"},{"location":"api/#chemrxn_cleaner.meta_filter","text":"meta_filter ( predicate ) Create a filter that tests metadata via a user predicate. Parameters: Name Type Description Default predicate Callable [[ Dict [ str , Any ]], bool ] Callable that receives extra_metadata and returns True to keep the reaction or False to drop it. required Returns: Type Description ReactionFilter ReactionFilter wrapping the predicate. Source code in chemrxn_cleaner/filters.py 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 def meta_filter ( predicate : Callable [[ Dict [ str , Any ]], bool ]) -> ReactionFilter : \"\"\"Create a filter that tests metadata via a user predicate. Args: predicate: Callable that receives ``extra_metadata`` and returns True to keep the reaction or False to drop it. Returns: ReactionFilter wrapping the predicate. \"\"\" def _filter ( record : ReactionRecord ) -> bool : \"\"\"Return True when the predicate accepts the record metadata. Args: record: Reaction to evaluate. Returns: Result of the predicate; False when the predicate raises. \"\"\" meta = record . extra_metadata or {} try : return predicate ( meta ) except Exception : # Treat predicate errors as a failed filter match return False pred_name = getattr ( predicate , \"__name__\" , predicate . __class__ . __name__ ) _filter . __name__ = f \"meta_filter( { pred_name } )\" return _filter","title":"meta_filter"},{"location":"api/#chemrxn_cleaner.export_reaction_records","text":"export_reaction_records ( records , path , * , fmt = None , indent = 2 ) Serialize reactions to the provided path as JSON or CSV. Parameters: Name Type Description Default records Sequence [ ReactionRecord ] Reaction records to serialize. required path str | Path Destination path for the file. required fmt str | None Output format; \"json\" or \"csv\" . When omitted, the format is inferred from the file extension. None indent int Indentation level for JSON output (ignored for CSV). 2 Source code in chemrxn_cleaner/io/writer.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 def export_reaction_records ( records : Sequence [ ReactionRecord ], path : str | Path , * , fmt : str | None = None , indent : int = 2 , ) -> None : \"\"\"Serialize reactions to the provided path as JSON or CSV. Args: records: Reaction records to serialize. path: Destination path for the file. fmt: Output format; ``\"json\"`` or ``\"csv\"``. When omitted, the format is inferred from the file extension. indent: Indentation level for JSON output (ignored for CSV). \"\"\" out_path = _ensure_path ( path ) resolved_fmt = ( fmt or out_path . suffix . lstrip ( \".\" )) . lower () if not resolved_fmt : raise ValueError ( \"File format not provided; supply fmt or a .json/.csv path.\" ) if resolved_fmt == \"json\" : _write_json ( records , out_path , indent = indent ) elif resolved_fmt == \"csv\" : _write_csv ( records , out_path ) else : raise ValueError ( f \"Unsupported export format ' { resolved_fmt } '. Use 'json' or 'csv'.\" )","title":"export_reaction_records"},{"location":"api/#chemrxn_cleaner.get_input_format","text":"get_input_format ( name ) Retrieve the loader registered for the given name. Parameters: Name Type Description Default name str Format name used during registration (e.g., \"uspto\" ). required Returns: Type Description InputLoader The loader callable for the specified format. Raises: Type Description InputFormatError If the format is not registered. Source code in chemrxn_cleaner/io/loader_registry.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 def get_input_format ( name : str ) -> InputLoader : \"\"\"Retrieve the loader registered for the given name. Args: name: Format name used during registration (e.g., ``\"uspto\"``). Returns: The loader callable for the specified format. Raises: InputFormatError: If the format is not registered. \"\"\" key = name . strip () . lower () try : return _INPUT_FORMAT_REGISTRY [ key ] except KeyError : available = \", \" . join ( sorted ( _INPUT_FORMAT_REGISTRY . keys ())) or \"<none>\" raise InputFormatError ( f \"Unknown input format ' { key } '. Available formats: { available } \" ) from None","title":"get_input_format"},{"location":"api/#chemrxn_cleaner.load_reactions","text":"load_reactions ( source : str , * , fmt : Literal [ 'uspto' ], keep_meta : bool = False , strip_atom_mapping : bool = False ) -> List [ ReactionRecord ] load_reactions ( source : str , * , fmt : Literal [ 'ord' ], generate_if_missing : bool = True , allow_incomplete : bool = True , canonical : bool = True , meta_extractor : Optional [ Callable [[ Any ], Dict [ str , Any ]]] = None , strip_atom_mapping : bool = False ) -> List [ ReactionRecord ] load_reactions ( source : str , * , fmt : Literal [ 'csv' ], reactant_columns : Sequence [ str ] = (), product_columns : Sequence [ str ] = (), reagent_columns : Optional [ Sequence [ str ]] = None , reaction_smiles_column : Optional [ str ] = None , delimiter : str = ',' , skip_lines : int = 0 , mapper : Optional [ Callable [[ ReactionRecord , Dict [ str , Any ]], Optional [ ReactionRecord ]]] = None , strip_atom_mapping : bool = False ) -> List [ ReactionRecord ] load_reactions ( source : str , * , fmt : Literal [ 'json' ], mapper : Callable [[ Any ], Optional [ ReactionRecord ]], strip_atom_mapping : bool = False ) -> List [ ReactionRecord ] load_reactions ( source : Any , * , fmt : str , ** kwargs : Any ) -> List [ ReactionRecord ] load_reactions ( source , * , fmt , ** kwargs ) Parse an external data source using a registered format loader. Parameters: Name Type Description Default source Any External data source such as a file path, DataFrame, or list. required fmt str Registered input format name (e.g., \"uspto\" , \"ord\" , \"csv\" ). required **kwargs Any Extra arguments forwarded to the selected loader. {} Returns: Type Description List [ ReactionRecord ] List of ReactionRecord instances produced by the loader. Source code in chemrxn_cleaner/io/loader_registry.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 def load_reactions ( source : Any , * , fmt : str , ** kwargs : Any , ) -> List [ ReactionRecord ]: \"\"\"Parse an external data source using a registered format loader. Args: source: External data source such as a file path, DataFrame, or list. fmt: Registered input format name (e.g., ``\"uspto\"``, ``\"ord\"``, ``\"csv\"``). **kwargs: Extra arguments forwarded to the selected loader. Returns: List of ``ReactionRecord`` instances produced by the loader. \"\"\" logger . info ( \"Loading reactions using format ' %s '\" , fmt ) loader = get_input_format ( fmt ) return list ( loader ( source , ** kwargs ))","title":"load_reactions"},{"location":"api/#chemrxn_cleaner.register_input_format","text":"register_input_format ( name , loader , * , overwrite = False ) Register a new input format. Parameters: Name Type Description Default name str Input format name (e.g., \"uspto\" , \"ord\" , \"csv\" ). Prefer lowercase with underscores. required loader InputLoader Callable with signature loader(source, **kwargs) returning an iterable of ReactionRecord instances. required overwrite bool When True, replace any existing loader registered under the same name. False Raises: Type Description InputFormatError If the name already exists and overwrite is False or the loader does not satisfy the protocol. Source code in chemrxn_cleaner/io/loader_registry.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def register_input_format ( name : str , loader : InputLoader , * , overwrite : bool = False , ) -> None : \"\"\"Register a new input format. Args: name: Input format name (e.g., ``\"uspto\"``, ``\"ord\"``, ``\"csv\"``). Prefer lowercase with underscores. loader: Callable with signature ``loader(source, **kwargs)`` returning an iterable of ``ReactionRecord`` instances. overwrite: When True, replace any existing loader registered under the same name. Raises: InputFormatError: If the name already exists and ``overwrite`` is False or the loader does not satisfy the protocol. \"\"\" key = name . strip () . lower () if not key : raise InputFormatError ( \"Input format name must be a non-empty string.\" ) if key in _INPUT_FORMAT_REGISTRY and not overwrite : raise InputFormatError ( f \"Input format ' { key } ' already exists. Use overwrite=True to replace it.\" ) if not isinstance ( loader , InputLoader ): # Type check is intentionally loose but can help catch issues early raise InputFormatError ( f \"Loader for format ' { key } ' does not match InputLoader protocol. \" f \"Expected callable(source, **kwargs) -> Iterable[ReactionRecord].\" ) _INPUT_FORMAT_REGISTRY [ key ] = loader logger . debug ( \"Registered input format ' %s ' (overwrite= %s )\" , key , overwrite )","title":"register_input_format"},{"location":"api/#chemrxn_cleaner.records_to_dataframe","text":"records_to_dataframe ( records ) Convert reaction records into a pandas.DataFrame . Parameters: Name Type Description Default records Iterable [ ReactionRecord ] Iterable of ReactionRecord instances. required Returns: Type Description DataFrame DataFrame containing flattened record fields; list fields are joined DataFrame with \" | \" separators for readability. Source code in chemrxn_cleaner/ml/utils.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def records_to_dataframe ( records : Iterable [ ReactionRecord ]) -> pd . DataFrame : \"\"\"Convert reaction records into a ``pandas.DataFrame``. Args: records: Iterable of ``ReactionRecord`` instances. Returns: DataFrame containing flattened record fields; list fields are joined with ``\" | \"`` separators for readability. \"\"\" rows = [] for r in records : row = asdict ( r ) # Flatten list fields to simple strings for CSV (optional) for key , value in list ( row . items ()): if isinstance ( value , list ): row [ key ] = \" | \" . join ( value ) rows . append ( row ) return pd . DataFrame ( rows )","title":"records_to_dataframe"},{"location":"api/#chemrxn_cleaner.train_valid_test_split","text":"train_valid_test_split ( records , train_ratio = 0.8 , valid_ratio = 0.1 , seed = 0 ) Randomly split records into train/valid/test partitions. Parameters: Name Type Description Default records List [ ReactionRecord ] Dataset to split. required train_ratio float Fraction of examples allocated to the training set. 0.8 valid_ratio float Fraction allocated to the validation set. 0.1 seed int Random seed for deterministic shuffling. 0 Returns: Type Description Tuple [ List [ ReactionRecord ], List [ ReactionRecord ], List [ ReactionRecord ]] Tuple of (train, valid, test) record lists. Source code in chemrxn_cleaner/ml/utils.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def train_valid_test_split ( records : List [ ReactionRecord ], train_ratio : float = 0.8 , valid_ratio : float = 0.1 , seed : int = 0 , ) -> Tuple [ List [ ReactionRecord ], List [ ReactionRecord ], List [ ReactionRecord ]]: \"\"\"Randomly split records into train/valid/test partitions. Args: records: Dataset to split. train_ratio: Fraction of examples allocated to the training set. valid_ratio: Fraction allocated to the validation set. seed: Random seed for deterministic shuffling. Returns: Tuple of ``(train, valid, test)`` record lists. \"\"\" rng = random . Random ( seed ) idxs = list ( range ( len ( records ))) rng . shuffle ( idxs ) n = len ( records ) n_train = int ( n * train_ratio ) n_valid = int ( n * valid_ratio ) train_idx = idxs [: n_train ] valid_idx = idxs [ n_train : n_train + n_valid ] test_idx = idxs [ n_train + n_valid :] def pick ( idxs_ ): \"\"\"Select records by shuffled indices. Args: idxs_: Indices to extract from the records list. Returns: Ordered list of ``ReactionRecord`` instances corresponding to ``idxs_``. \"\"\" return [ records [ i ] for i in idxs_ ] return pick ( train_idx ), pick ( valid_idx ), pick ( test_idx )","title":"train_valid_test_split"},{"location":"api/#chemrxn_cleaner.canonicalize_reaction","text":"canonicalize_reaction ( record , isomeric = True ) Return a new ReactionRecord with all SMILES canonicalized. Parameters: Name Type Description Default record ReactionRecord Reaction record to convert. required isomeric bool Preserve stereochemistry in canonical SMILES when True. True Returns: Type Description ReactionRecord A new ReactionRecord containing canonicalized SMILES and copied metadata. Source code in chemrxn_cleaner/parser.py 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 def canonicalize_reaction ( record : ReactionRecord , isomeric : bool = True , ) -> ReactionRecord : \"\"\"Return a new ReactionRecord with all SMILES canonicalized. Args: record: Reaction record to convert. isomeric: Preserve stereochemistry in canonical SMILES when True. Returns: A new ReactionRecord containing canonicalized SMILES and copied metadata. \"\"\" canon_reactants = canonicalize_smiles_list ( record . reactants , isomeric = isomeric ) canon_reagents = canonicalize_smiles_list ( record . reagents , isomeric = isomeric ) canon_products = canonicalize_smiles_list ( record . products , isomeric = isomeric ) return ReactionRecord ( reaction_smiles = record . reaction_smiles , reactants = canon_reactants , reagents = canon_reagents , products = canon_products , extra_metadata = dict ( record . extra_metadata or {}), )","title":"canonicalize_reaction"},{"location":"api/#chemrxn_cleaner.parse_reaction_smiles","text":"parse_reaction_smiles ( rxn_smiles , strict = True , strip_atom_mapping = False ) Parse a reaction SMILES string into a ReactionRecord . Reaction SMILES must follow reactants>reagents>products . When strict is False, missing fields are padded with empty strings instead of raising. Parameters: Name Type Description Default rxn_smiles str Raw reaction SMILES string to parse. required strict bool Enforce exactly three > -separated parts when True. True strip_atom_mapping bool When True, remove atom-map numbers and store the original mapped string in atom_mapping . False Returns: Type Description ReactionRecord ReactionRecord with parsed reactants, reagents, and products lists. Raises: Type Description ValueError If rxn_smiles is None or incorrectly formatted when strict is True. Source code in chemrxn_cleaner/parser.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 def parse_reaction_smiles ( rxn_smiles : str , strict : bool = True , strip_atom_mapping : bool = False , ) -> ReactionRecord : \"\"\"Parse a reaction SMILES string into a ``ReactionRecord``. Reaction SMILES must follow ``reactants>reagents>products``. When ``strict`` is False, missing fields are padded with empty strings instead of raising. Args: rxn_smiles: Raw reaction SMILES string to parse. strict: Enforce exactly three ``>``-separated parts when True. strip_atom_mapping: When True, remove atom-map numbers and store the original mapped string in ``atom_mapping``. Returns: ReactionRecord with parsed reactants, reagents, and products lists. Raises: ValueError: If ``rxn_smiles`` is None or incorrectly formatted when ``strict`` is True. \"\"\" if rxn_smiles is None : logger . error ( \"rxn_smiles cannot be None.\" ) raise ValueError ( \"rxn_smiles cannot be None.\" ) rxn_smiles = rxn_smiles . strip () atom_mapping : Optional [ str ] = None if strip_atom_mapping : rxn_smiles , atom_mapping = _strip_atom_mapping_tokens ( rxn_smiles ) parts = rxn_smiles . split ( \">\" ) if len ( parts ) != 3 : if strict : logger . error ( \"Invalid reaction SMILES format: %r \" , rxn_smiles ) raise ValueError ( f \"Invalid reaction SMILES format: { rxn_smiles !r} \" ) else : # Pad or truncate to length 3 parts = ( parts + [ \"\" , \"\" , \"\" ])[: 3 ] reactants_block , reagents_block , products_block = parts reactants = parse_smiles_list ( reactants_block ) reagents = parse_smiles_list ( reagents_block ) products = parse_smiles_list ( products_block ) return ReactionRecord ( reaction_smiles = rxn_smiles , reactants = reactants , reagents = reagents , products = products , atom_mapping = atom_mapping , )","title":"parse_reaction_smiles"},{"location":"api/#chemrxn_cleaner.similarity_filter","text":"similarity_filter ( query_smiles , role = 'any' , threshold = 0.7 , radius = 2 , n_bits = 2048 ) Return a similarity-based ReactionFilter . Parameters: Name Type Description Default query_smiles Union [ str , List [ str ]] Target structure(s) expressed as SMILES. required role Literal ['reactant', 'reagent', 'product', 'any'] Molecular role(s) to check; \"any\" inspects reactants, reagents, and products. 'any' threshold float Tanimoto similarity cutoff; scores >= threshold count as a hit. 0.7 radius int Morgan fingerprint radius (2 for ECFP4, 3 for ECFP6). 2 n_bits int Length of the fingerprint bit vector. 2048 Returns: Type Description ReactionFilter ReactionFilter predicate that keeps reactions containing at least one ReactionFilter molecule similar to the query. Raises: Type Description ValueError If any query SMILES cannot be parsed. Source code in chemrxn_cleaner/utils/similarity.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def similarity_filter ( query_smiles : Union [ str , List [ str ]], role : Literal [ \"reactant\" , \"reagent\" , \"product\" , \"any\" ] = \"any\" , threshold : float = 0.7 , radius : int = 2 , n_bits : int = 2048 , ) -> ReactionFilter : \"\"\"Return a similarity-based ``ReactionFilter``. Args: query_smiles: Target structure(s) expressed as SMILES. role: Molecular role(s) to check; ``\"any\"`` inspects reactants, reagents, and products. threshold: Tanimoto similarity cutoff; scores >= ``threshold`` count as a hit. radius: Morgan fingerprint radius (2 for ECFP4, 3 for ECFP6). n_bits: Length of the fingerprint bit vector. Returns: ReactionFilter predicate that keeps reactions containing at least one molecule similar to the query. Raises: ValueError: If any query SMILES cannot be parsed. \"\"\" cfg = FingerprintConfig ( radius = radius , n_bits = n_bits ) # Normalize into a list if isinstance ( query_smiles , str ): query_list = [ query_smiles ] else : query_list = list ( query_smiles ) # Pre-compute all query fingerprints query_fps : List [ DataStructs . ExplicitBitVect ] = [] for q in query_list : fp = _fingerprint_from_smiles ( q , cfg ) if fp is None : raise ValueError ( f \"Invalid query SMILES: { q } \" ) query_fps . append ( fp ) def _filter ( rxn : ReactionRecord ) -> bool : \"\"\"Return True when any molecule exceeds the similarity threshold. Args: rxn: Reaction to compare against the query fingerprints. Returns: True when at least one molecule meets or exceeds ``threshold``. \"\"\" # Adjust here if you need every query matched instead of any for smi in _iter_molecule_smiles ( rxn , role ): fp = _fingerprint_from_smiles ( smi , cfg ) if fp is None : continue # Compare with all queries; any sufficiently similar molecule counts for qfp in query_fps : sim = DataStructs . TanimotoSimilarity ( fp , qfp ) if sim >= threshold : return True return False _filter . __name__ = \"similarity_filter\" return _filter","title":"similarity_filter"}]}